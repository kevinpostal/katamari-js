<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Katamari World</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --king-face-url: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNNTAsNC41QTEwLDggMCAwIDEgNjAsMTIgNDUsNDUgMCAxIDEgNSw1MCA0NSw0NSAwIDAgMSA1MCw0LjVaIiBmaWxsPSIjNjcwYWRkIi8+PHBhdGggZD0iTTUwLDQ1QTUsNSAwIDAgMSw1NSw1MCA1LDUgMCAwIDEgNTAsNTUgNSw1IDAgMCAxIDQ1LDUwIDUsNSAwIDAgMSA1MCw0NVoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNNzUsMzBBNSw1IDAgMSAxIDY1LDMwIDUsNSAwIDAgMSA3NSwzMFoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMjUsMzBBNSw1IDAgMSAxIDM1LDMwIDUsNSAwIDAgMSAyNSwzMFoiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNNTAsNzBBMTUsMTIgMCAwIDEgNjUsNzUgMTUsMTIgMCAwIDEgNTAsODAgMTUsMTIgMCAwIDEgMzUsNzUgMTUsMTIgMCAwIDEgNTAsNzBaIiBmaWxsPSIjZmYwMDQ3Ii8+PC9zdmc+');
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Press Start 2P', 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
        }
        #start-screen {
            padding: 20px;
        }
        #start-screen h1 {
            font-size: 3em;
            color: #FFD700;
            text-shadow: 0 0 15px #FFD700;
            margin-bottom: 20px;
            animation: pulse 2s infinite alternate;
        }
        #start-screen p {
            font-size: 1em;
            max-width: 600px;
            line-height: 1.5;
            margin-bottom: 40px;
        }
        #start-button {
            font-family: 'Press Start 2P', 'Arial', sans-serif;
            font-size: 1.5em;
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: 3px solid white;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        #start-button:hover {
            background-color: #66BB6A;
            transform: scale(1.1);
        }
        #loading-overlay {
            display: none; /* Hidden by default */
            font-size: 2em;
            text-shadow: 0 0 15px rgba(255,255,255,0.8);
        }
        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #progress-container {
            width: 200px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            border: 1px solid rgba(255,255,255,0.4);
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            border-radius: 10px;
            transition: width 0.1s ease-out;
        }
        #message-overlay {
            padding: 30px;
            border-radius: 15px;
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD700;
            display: none; /* Hidden by default */
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            cursor: pointer;
        }
        #message-overlay::before {
            content: '';
            display: block;
            width: 100px;
            height: 100px;
            margin: 0 auto 20px;
            background-image: var(--king-face-url);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        #controls-info {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 10px;
            color: #ccc;
            z-index: 10;
            text-align: center;
        }
        #gyro-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 10px;
            transition: background-color 0.2s ease;
            display: none; /* Hidden by default */
        }
        #gyro-button:hover {
            background-color: #0056b3;
        }
        #gyro-button.active {
            background-color: #28a745;
        }
        #gyro-button.active:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <div id="start-screen" class="overlay">
        <h1>Katamari World</h1>
        <p>The King of All Cosmos has had a little... accident. It's up to you, the Prince, to roll up everything and make new stars! Use W,A,S,D or Swipe to roll!</p>
        <button id="start-button">Start Rolling!</button>
    </div>

    <div id="loading-overlay" class="overlay">Generating a new universe... âœ¨</div>
    
    <div id="game-ui" style="display: none;">
        <div>Size: <span id="katamari-size">2.00m</span></div>
        <div>Speed: <span id="katamari-speed">0.00m/s</span></div>
        <div>Items: <span id="items-collected">0</span></div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <div>Target: <span id="target-size">100.00m</span></div>
        <button id="gyro-button">Toggle Gyro</button>
    </div>

    <div id="controls-info" style="display: none;">
        <p><b>W,A,S,D/Arrows/Swipe:</b> Move | <b>R:</b> Reset | <b>Space:</b> New World</p>
    </div>

    <div id="message-overlay" class="overlay"></div>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js';

        // --- SCENE/PHYSICS SETUP ---
        let scene, camera, renderer, world, starfield;
        let katamari, ground, groundBody;
        let itemsToCollect = [], physicsBodies = [];
        let mountains = [];
        let katamariRadius = 2, targetKatamariSize = 100, itemsCollectedCount = 0;
        let rollingSynth, collectionSynth, shedSound, bumpSynth;
        const keys = {}, clock = new THREE.Clock();
        const moveSpeed = 15, timeStep = 1 / 60; 
        let currentLevel = 1;
        let isGeneratingLevel = false;
        let smoothedSpeed = 0;
        let currentTheme;

        // --- COOLDOWNS & EFFECTS ---
        let lastCollectionSoundTime = 0;
        const collectionSoundCooldown = 0.05;
        let lastShedTime = 0;
        const shedCooldown = 1000;
        let lastBumpSoundTime = 0;
        const bumpSoundCooldown = 0.1;
        let wobble = { active: false, time: 0, duration: 0.3, magnitude: 0.1 };

        // --- DYNAMIC GENERATION ---
        let lastGenerationPosition = new THREE.Vector3();
        const generationDistanceThreshold = 50;
        const cleanupDistanceThreshold = 200;
        const mapBoundary = 240;
        const physicsActiveDistance = 100;
        const itemFadeDuration = 1000; 

        // --- CORE COMPONENTS ---
        const frustum = new THREE.Frustum();
        let katamariBody;
        let particles = [];

        // --- INPUT VARIABLES ---
        const touchInput = { startX: 0, startY: 0, currentX: 0, currentY: 0, active: false };
        const touchDeadZone = Math.min(30, window.innerWidth * 0.05); 
        const touchSensitivity = 0.5;
        let useGyroscope = false;
        let gyro = { alpha: 0, beta: 0, gamma: 0 };
        const gyroSensitivity = 0.3;

        // --- UI ELEMENTS ---
        const katamariSizeUI = document.getElementById('katamari-size');
        const katamariSpeedUI = document.getElementById('katamari-speed');
        const itemsCollectedUI = document.getElementById('items-collected');
        const progressBar = document.getElementById('progress-bar');
        const targetSizeUI = document.getElementById('target-size');
        const messageOverlay = document.getElementById('message-overlay');
        const loadingOverlay = document.getElementById('loading-overlay');
        const gyroButton = document.getElementById('gyro-button');
        const startButton = document.getElementById('start-button');
        const startScreen = document.getElementById('start-screen');
        const gameUI = document.getElementById('game-ui');
        const controlsInfo = document.getElementById('controls-info');

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 15, 30);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            world = new CANNON.World({ gravity: new CANNON.Vec3(0, -20, 0) });
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.solver.iterations = 7;
            world.defaultContactMaterial.friction = 0.7;
            world.defaultContactMaterial.restitution = 0.3;

            scene.add(new THREE.AmbientLight(0x404040));
            const hemiLight = new THREE.HemisphereLight(0xADD8E6, 0x8B4513, 0.8);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            Object.assign(dirLight.shadow.camera, { top: 50, bottom: -50, left: -50, right: 50 });
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            createStarfield();
            
            // Event listeners are set up once
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.key.toLowerCase() === ' ') generateNewLevel();
                else if (e.key.toLowerCase() === 'r') resetKatamariPosition();
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            gyroButton.addEventListener('click', toggleGyroscope);
            window.addEventListener('resize', onWindowResize);
            messageOverlay.addEventListener('click', () => generateNewLevel());
            startButton.addEventListener('click', startGame);
        }

        async function startGame() {
            startScreen.style.display = 'none';
            gameUI.style.display = 'flex';
            controlsInfo.style.display = 'block';

            // Initialize Tone.js on first user interaction
            await Tone.start();
            console.log("Audio context started.");

            const rollingFilter = new Tone.AutoFilter("4n").toDestination().start();
            rollingSynth = new Tone.NoiseSynth({
                noise: { type: "brown" }, // Changed to brown noise
                envelope: { attack: 0.1, decay: 0.2, sustain: 1, release: 0.1 }
            }).connect(rollingFilter);
            rollingSynth.volume.value = -35; // Start quieter
            
            collectionSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            collectionSynth.volume.value = -10;
            shedSound = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2, attackCurve: "exponential" }, oscillator: { type: "sine" }, volume: -15 }).toDestination();
            bumpSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1 }, volume: -20 }).toDestination();

            setupGyroButtonVisibility();
            await generateNewLevel();
            animate();
        }

        // --- TOUCH & GYRO ---
        function onTouchStart(event) { event.preventDefault(); touchInput.active = true; touchInput.startX = event.touches[0].clientX; touchInput.startY = event.touches[0].clientY; touchInput.currentX = touchInput.startX; touchInput.currentY = touchInput.startY; }
        function onTouchMove(event) { event.preventDefault(); if (touchInput.active) { touchInput.currentX = event.touches[0].clientX; touchInput.currentY = event.touches[0].clientY; } }
        function onTouchEnd() { touchInput.active = false; }
        function handleDeviceOrientation(event) { gyro.gamma = event.gamma; gyro.beta = event.beta; }
        function toggleGyroscope() {
            if (useGyroscope) {
                window.removeEventListener('deviceorientation', handleDeviceOrientation);
                useGyroscope = false;
                gyroButton.classList.remove('active');
                gyroButton.textContent = 'Toggle Gyro';
            } else {
                const permissionHandler = () => {
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                    useGyroscope = true;
                    gyroButton.classList.add('active');
                    gyroButton.textContent = 'Gyro ON';
                };
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(state => state === 'granted' ? permissionHandler() : alert("Gyroscope permission denied."))
                        .catch(err => alert("Could not enable gyroscope."));
                } else {
                    permissionHandler();
                }
            }
        }
        function setupGyroButtonVisibility() {
            if (window.matchMedia("(pointer: coarse)").matches || 'DeviceOrientationEvent' in window) {
                gyroButton.style.display = 'block';
            } else {
                gyroButton.style.display = 'none';
            }
        }

        // --- LEVEL GENERATION ---
        async function generateLevelTheme() {
            loadingOverlay.style.display = 'flex';
            const themes = [
                { name: "Our Green Earth", items: ["Car", "Tree", "House", "Rock", "Bush", "Bench", "Lamp Post", "Trash Can", "Mailbox"], ground: "#4CAF50", sky: "#87CEEB", target: 100 },
                { name: "Urban Jungle", items: ["Car", "Lamp Post", "Trash Can", "Bench", "Mailbox", "Fire Hydrant", "Traffic Cone", "Hot Dog Stand"], ground: "#607D8B", sky: "#B0C4DE", target: 200 },
                { name: "Cosmic Debris", items: ["Asteroid", "Satellite", "Space Debris", "Comet Fragment", "Moon Rock", "Star Dust Cluster"], ground: "#2C3E50", sky: "#0A0A2A", target: 400 }
            ];
            const theme = themes[(currentLevel - 1) % themes.length];
            loadingOverlay.textContent = `Generating ${theme.name}... âœ¨`;
            await new Promise(r => setTimeout(r, 500)); // Shorter wait
            loadingOverlay.style.display = 'none';
            return theme;
        }

        async function generateNewLevel() {
            isGeneratingLevel = true;
            stopRollingSound();
            messageOverlay.style.display = 'none';

            // Full physics world reset
            world = new CANNON.World({ gravity: new CANNON.Vec3(0, -20, 0) });
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.solver.iterations = 7;
            world.defaultContactMaterial.friction = 0.7;
            world.defaultContactMaterial.restitution = 0.3;

            // Clean up scene
            if (katamari) scene.remove(katamari);
            if (ground) scene.remove(ground);
            itemsToCollect.forEach(item => scene.remove(item));
            mountains.forEach(m => scene.remove(m));
            
            itemsToCollect = [];
            physicsBodies = [];
            mountains = [];
            itemsCollectedCount = 0;
            itemsCollectedUI.textContent = itemsCollectedCount;

            currentTheme = await generateLevelTheme();
            const difficultyFactor = 1 + (currentLevel - 1) * 0.5;
            targetKatamariSize = currentTheme.target * difficultyFactor; 
            targetSizeUI.textContent = targetKatamariSize.toFixed(2) + 'm';

            scene.background = new THREE.Color(currentTheme.sky);
            scene.fog = new THREE.Fog(currentTheme.sky, 50, 200);
            starfield.visible = currentTheme.name === 'Cosmic Debris';

            createEnvironment(currentTheme);

            const groundColor1 = new THREE.Color(currentTheme.ground);
            const groundColor2 = groundColor1.clone().lerp(new THREE.Color(0x000000), 0.1);
            const groundMat = new THREE.MeshLambertMaterial({ map: generateGroundTexture(groundColor1, groundColor2) });
            ground = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            katamariRadius = 2;
            katamari = new THREE.Group();
            const katamariBall = new THREE.Mesh(
                new THREE.SphereGeometry(katamariRadius, 32, 32),
                new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(generateKatamariTexture()), roughness: 0.6, metalness: 0.1 })
            );
            katamariBall.castShadow = true;
            katamariBall.name = 'core';
            katamari.add(katamariBall);
            scene.add(katamari);
            
            katamariBody = new CANNON.Body({
                mass: 100,
                position: new CANNON.Vec3(0, katamariRadius, 0),
                shape: new CANNON.Sphere(katamariRadius),
                linearDamping: 0.3,
                angularDamping: 0.4
            });
            world.addBody(katamariBody);

            lastGenerationPosition.copy(katamari.position);
            createCollectibleItems(200, currentTheme.items, new THREE.Vector3(0,0,0), 180);
            isGeneratingLevel = false;
        }

        function createEnvironment(theme) {
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, roughness: 1 });
            for (let i = 0; i < 15; i++) {
                const cloud = new THREE.Mesh(new THREE.SphereGeometry(Math.random() * 8 + 5, 16, 16), cloudMat);
                cloud.position.set((Math.random() - 0.5) * 400, 50 + Math.random() * 30, (Math.random() - 0.5) * 400);
                scene.add(cloud);
                mountains.push(cloud); // Use mountains array for all env objects to be cleaned
            }

            const mountainColor = new THREE.Color(theme.ground).lerp(new THREE.Color(0x000000), 0.2);
            const mountainMat = new THREE.MeshStandardMaterial({ color: mountainColor, roughness: 0.8 });
            for (let i = 0; i < 8; i++) {
                const h = Math.random() * 50 + 30, r = Math.random() * 40 + 20;
                const mountain = new THREE.Mesh(new THREE.ConeGeometry(r, h, 16), mountainMat);
                mountain.castShadow = mountain.receiveShadow = true;
                mountain.userData.size = r;
                mountain.userData.minSizeToPass = r * 1.8;
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 500;
                    z = (Math.random() - 0.5) * 500;
                } while (Math.sqrt(x*x + z*z) < 50);
                mountain.position.set(x, h / 2 - 0.1, z);
                scene.add(mountain);
                mountains.push(mountain);
            }
        }

        function createStarfield() {
            const vertices = [];
            for (let i = 0; i < 10000; i++) {
                vertices.push(THREE.MathUtils.randFloatSpread(2000)); // x
                vertices.push(THREE.MathUtils.randFloatSpread(2000)); // y
                vertices.push(THREE.MathUtils.randFloatSpread(2000)); // z
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, fog: false });
            starfield = new THREE.Points(geometry, material);
            scene.add(starfield);
        }

        // --- TEXTURE GENERATION ---
        function generateKatamariTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 50%)`;
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 150; i++) {
                ctx.fillStyle = `hsl(${Math.random() * 360}, 90%, ${60 + Math.random() * 20}%)`;
                ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                ctx.beginPath();
                if (Math.random() < 0.5) {
                    ctx.fillRect(Math.random() * 256, Math.random() * 256, Math.random() * 30 + 10, Math.random() * 30 + 10);
                } else {
                    ctx.arc(Math.random() * 256, Math.random() * 256, Math.random() * 15 + 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            return canvas;
        }

        function generateGroundTexture(color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 128;
            const ctx = canvas.getContext('2d');
            for (let x = 0; x < 128; x++) {
                for (let y = 0; y < 128; y++) { 
                    const noise = Math.sin(x * 0.1) * 0.5 + Math.cos(y * 0.1) * 0.5 + 1;
                    const blend = (noise / 2) * 0.4 + 0.6;
                    const r = Math.floor(color1.r * 255 * blend + color2.r * 255 * (1 - blend));
                    const g = Math.floor(color1.g * 255 * blend + color2.g * 255 * (1 - blend));
                    const b = Math.floor(color1.b * 255 * blend + color2.b * 255 * (1 - blend));
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }

        // --- ITEM CREATION (REFACTORED) ---
        function _createGrouped(geometries, size, color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, transparent: true, opacity: 0 });
            geometries.forEach(({geo, pos, rot}) => {
                const mesh = new THREE.Mesh(geo, mat);
                if (pos) mesh.position.copy(pos);
                if (rot) mesh.rotation.copy(rot);
                mesh.castShadow = mesh.receiveShadow = true;
                group.add(mesh);
            });
            return group;
        }

        const itemPrototypes = {
            'Car': {
                createMesh(size, color) {
                    const bodyGeo = new THREE.BoxGeometry(size * 2, size * 0.8, size);
                    const cabinGeo = new THREE.BoxGeometry(size * 1.2, size * 0.6, size * 0.8);
                    const wheelGeo = new THREE.CylinderGeometry(size * 0.25, size * 0.25, size * 0.2, 16);
                    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333, roughness: 0.8, transparent: true, opacity: 0 });
                    const car = _createGrouped([{geo: bodyGeo}, {geo: cabinGeo, pos: new THREE.Vector3(0, size * 0.7, 0)}], size, color);
                    [[0.7, 0.5], [-0.7, 0.5], [0.7, -0.5], [-0.7, -0.5]].forEach(([dx, dz]) => {
                        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(size * dx, -size * 0.2, size * dz);
                        car.add(wheel);
                    });
                    return car;
                },
                createShape: (size) => new CANNON.Box(new CANNON.Vec3(size, size * 0.4, size * 0.5)),
                getSize: () => Math.random() * 2 + 0.8,
                getCollectionSize: (size) => size * 2,
            },
            'Tree': {
                createMesh(size, color) {
                    const group = new THREE.Group();
                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.5, transparent: true, opacity: 0 });
                    
                    const trunkGeo = new THREE.CylinderGeometry(size * 0.1, size * 0.15, size, 8);
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = size * 0.5;
                    trunk.castShadow = trunk.receiveShadow = true;
                    
                    const foliageGeo = new THREE.IcosahedronGeometry(size * 0.6, 0);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = size * 1.2;
                    foliage.castShadow = foliage.receiveShadow = true;

                    group.add(trunk, foliage);
                    return group;
                },
                createShape: (size) => new CANNON.Cylinder(size * 0.15, size * 0.6, size * 1.5, 8),
                getSize: () => Math.random() * 3 + 1.5,
                getCollectionSize: (size) => size * 1.5,
            },
            'House': {
                createMesh(size, color) {
                    const bodyGeo = new THREE.BoxGeometry(size * 1.5, size, size * 1.5);
                    const roofGeo = new THREE.ConeGeometry(size * 1.2, size * 0.8, 4);
                    return _createGrouped([
                        { geo: bodyGeo },
                        { geo: roofGeo, pos: new THREE.Vector3(0, size * 0.9, 0), rot: new THREE.Euler(0, Math.PI / 4, 0) }
                    ], size, color);
                },
                createShape: (size) => new CANNON.Box(new CANNON.Vec3(size * 0.75, size * 0.75, size * 0.75)),
                getSize: () => Math.random() * 2 + 1,
                getCollectionSize: (size) => size * 1.5,
            },
            // Add other items here...
            'Rock': { createShape: (s) => new CANNON.Sphere(s*0.7), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s, createMesh(s, c) { return new THREE.Mesh(new THREE.SphereGeometry(s*0.7, 16, 16), new THREE.MeshStandardMaterial({color:c, roughness:0.8, transparent:true, opacity:0}))}},
            'Bush': { createShape: (s) => new CANNON.Sphere(s*0.8), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s, createMesh(s, c) { return new THREE.Mesh(new THREE.SphereGeometry(s*0.8, 24, 24), new THREE.MeshStandardMaterial({color:c, roughness:0.8, transparent:true, opacity:0}))}},
            'Bench': { createShape: (s) => new CANNON.Box(new CANNON.Vec3(s, s*0.25, s*0.25)), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s, createMesh(s, c) { return new THREE.Mesh(new THREE.BoxGeometry(s*2, s*0.5, s*0.5), new THREE.MeshStandardMaterial({color:c, roughness:0.6, transparent:true, opacity:0}))}},
            'Lamp Post': { createShape: (s) => new CANNON.Cylinder(s*0.1, s*0.1, s*3, 16), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s, createMesh(s, c) { return new THREE.Mesh(new THREE.CylinderGeometry(s*0.1, s*0.1, s*3, 16), new THREE.MeshStandardMaterial({color:c, roughness:0.6, transparent:true, opacity:0}))}},
            'Trash Can': { createShape: (s) => new CANNON.Cylinder(s*0.4, s*0.5, s*1.2, 24), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s, createMesh(s, c) { return new THREE.Mesh(new THREE.CylinderGeometry(s*0.4, s*0.5, s*1.2, 24), new THREE.MeshStandardMaterial({color:c, roughness:0.6, transparent:true, opacity:0}))}},
            'Mailbox': { createShape: (s) => new CANNON.Box(new CANNON.Vec3(s*0.4, s*0.75, s*0.25)), getSize: () => Math.random()*0.8+0.3, getCollectionSize: (s) => s*1.5, createMesh(s, c) { return _createGrouped([{geo: new THREE.CylinderGeometry(s*0.1, s*0.1, s*1.5, 8), pos: new THREE.Vector3(0, s*0.75, 0)}, {geo: new THREE.BoxGeometry(s*0.8, s*0.5, s*0.5), pos: new THREE.Vector3(0, s*1.5, 0)}], s, c)}},
            'Fire Hydrant': { createShape: (s) => new CANNON.Cylinder(s*0.5, s*0.5, s*1.5, 16), getSize: () => Math.random()*0.7+0.3, getCollectionSize: (s) => s*1.5, createMesh(s, c) { return _createGrouped([{geo: new THREE.CylinderGeometry(s*0.4, s*0.5, s*0.3, 16), pos: new THREE.Vector3(0, s*0.15, 0)}, {geo: new THREE.CylinderGeometry(s*0.3, s*0.3, s*0.8, 16), pos: new THREE.Vector3(0, s*0.7, 0)}], s, c)}},
            'Traffic Cone': { createShape: (s) => new CANNON.Cylinder(0, s*0.5, s*1.5, 16), getSize: () => Math.random()*0.5+0.2, getCollectionSize: (s) => s*1.5, createMesh(s, c) { return new THREE.Mesh(new THREE.ConeGeometry(s*0.5, s*1.5, 16), new THREE.MeshStandardMaterial({color:0xFFA500, roughness:0.6, transparent:true, opacity:0}))}},
            'Hot Dog Stand': { createShape: (s) => new CANNON.Box(new CANNON.Vec3(s*0.75, s*0.5, s*0.4)), getSize: () => Math.random()*1.5+0.8, getCollectionSize: (s) => s*2, createMesh(s, c) { return _createGrouped([{geo: new THREE.BoxGeometry(s*1.5, s*0.8, s*0.8), pos: new THREE.Vector3(0, s*0.4, 0)}, {geo: new THREE.BoxGeometry(s*1.8, s*0.2, s*1), pos: new THREE.Vector3(0, s*1.1, 0)}], s, c)}},
            'Asteroid': { createShape: (s) => new CANNON.Sphere(s), getSize: () => Math.random()*3+1, getCollectionSize: (s) => s*2, createMesh(s, c) { return new THREE.Mesh(new THREE.IcosahedronGeometry(s, 0), new THREE.MeshStandardMaterial({color:0x696969, roughness:0.9, flatShading:true, transparent:true, opacity:0}))}},
            'Satellite': { createShape: (s) => new CANNON.Box(new CANNON.Vec3(s*1.25, s*0.25, s*0.75)), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s*2.5, createMesh(s, c) { return _createGrouped([{geo: new THREE.BoxGeometry(s*0.5, s*0.5, s*1.5)}, {geo: new THREE.BoxGeometry(s*2, 0.05, s*0.8), pos: new THREE.Vector3(s*1.25, 0, 0)}, {geo: new THREE.BoxGeometry(s*2, 0.05, s*0.8), pos: new THREE.Vector3(-s*1.25, 0, 0)}], s, c)}},
            'Space Debris': { createShape: (s) => new CANNON.Box(new CANNON.Vec3(s*0.5, s*0.5, s*0.5)), getSize: () => Math.random()*0.8+0.2, getCollectionSize: (s) => s, createMesh(s, c) { return new THREE.Mesh(new THREE.BoxGeometry(s,s,s), new THREE.MeshStandardMaterial({color:0x555, roughness:0.7, transparent:true, opacity:0}))}},
            'Comet Fragment': { createShape: (s) => new CANNON.Sphere(s), getSize: () => Math.random()*1.2+0.4, getCollectionSize: (s) => s*1.5, createMesh(s, c) { return new THREE.Mesh(new THREE.IcosahedronGeometry(s, 1), new THREE.MeshStandardMaterial({color:0xADD8E6, roughness:0.8, flatShading:true, transparent:true, opacity:0}))}},
            'Moon Rock': { createShape: (s) => new CANNON.Sphere(s), getSize: () => Math.random()*1.5+0.5, getCollectionSize: (s) => s*1.2, createMesh(s, c) { return new THREE.Mesh(new THREE.DodecahedronGeometry(s, 0), new THREE.MeshStandardMaterial({color:0xA9A9A9, roughness:0.9, flatShading:true, transparent:true, opacity:0}))}},
            'Star Dust Cluster': { createShape: (s) => new CANNON.Sphere(s), getSize: () => Math.random()*0.6+0.1, getCollectionSize: (s) => s*2, createMesh(s, c) { const g = new THREE.Group(); for(let i=0;i<10;i++){ const p = new THREE.Mesh(new THREE.SphereGeometry(s*0.2, 8, 8), new THREE.MeshBasicMaterial({color:0xFFFFFF, transparent:true, opacity:0.8})); p.position.set((Math.random()-0.5)*s, (Math.random()-0.5)*s, (Math.random()-0.5)*s); g.add(p);} return g;}},
        };

        function createCollectibleItems(count, itemNames, centerPosition, spawnRadius) {
            if (!itemNames || itemNames.length === 0) return;
            const itemColors = [0xFF6347, 0x6A5ACD, 0x3CB371, 0xFFD700, 0xBA55D3, 0x4682B4, 0xD2B48C, 0xFFA07A, 0x20B2AA, 0xFF69B4];
            
            for (let i = 0; i < count; i++) {
                const itemName = itemNames[Math.floor(Math.random() * itemNames.length)];
                const proto = itemPrototypes[itemName];
                if (!proto) { console.warn(`Unknown item prototype: ${itemName}`); continue; }

                const size = proto.getSize();
                const color = itemColors[Math.floor(Math.random() * itemColors.length)];
                const threeMesh = proto.createMesh(size, color);
                const cannonShape = proto.createShape(size);
                
                threeMesh.userData.size = proto.getCollectionSize(size);
                threeMesh.userData.cannonShape = cannonShape;
                threeMesh.castShadow = threeMesh.receiveShadow = true;

                let x, z, attempts = 0;
                const maxAttempts = 20;
                do {
                    x = centerPosition.x + (Math.random() - 0.5) * spawnRadius * 2;
                    z = centerPosition.z + (Math.random() - 0.5) * spawnRadius * 2;
                    attempts++;
                } while (frustum.intersectsSphere(new THREE.Sphere(new THREE.Vector3(x, size/2, z), size/2)) && attempts < maxAttempts);

                x = THREE.MathUtils.clamp(x, -mapBoundary, mapBoundary);
                z = THREE.MathUtils.clamp(z, -mapBoundary, mapBoundary);
                const y = threeMesh.userData.size / 2;

                threeMesh.position.set(x, y, z);
                threeMesh.rotation.set(0, Math.random() * Math.PI * 2, 0);
                scene.add(threeMesh);
                itemsToCollect.push(threeMesh);

                threeMesh.userData.fadeStartTime = Date.now();
                threeMesh.userData.isFadingIn = true;

                const itemBody = new CANNON.Body({ mass: threeMesh.userData.size * 5, shape: cannonShape, position: new CANNON.Vec3(x, y, z) });
                itemBody.quaternion.copy(threeMesh.quaternion);
                itemBody.userData = { threeMesh }; 
                world.addBody(itemBody);
                physicsBodies.push(itemBody);
            }
        }

        function resetKatamariPosition() {
            if (katamariBody) {
                katamariBody.position.set(0, katamariRadius, 0);
                katamariBody.velocity.set(0,0,0);
                katamariBody.angularVelocity.set(0,0,0);
                lastGenerationPosition.copy(katamariBody.position);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if (isGeneratingLevel || !katamari || !world) {
                if (renderer && scene && camera) renderer.render(scene, camera);
                return;
            }

            const deltaTime = clock.getDelta();
            camera.updateMatrixWorld();
            frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

            // Physics update
            try {
                world.step(timeStep, deltaTime);
            } catch (e) {
                console.error("Physics step error:", e);
                renderer.render(scene, camera);
                return;
            }

            // Sync visuals with physics
            katamari.position.copy(katamariBody.position);
            katamari.quaternion.copy(katamariBody.quaternion);
            physicsBodies.forEach(body => {
                if (body.userData && body.userData.threeMesh) {
                    body.userData.threeMesh.position.copy(body.position);
                    body.userData.threeMesh.quaternion.copy(body.quaternion);
                }
            });

            // Effects and updates
            updateItemFading();
            updateParticles(deltaTime);
            updateKatamariMovement(deltaTime);
            updateWobble(deltaTime);

            // Clamp position
            katamariBody.position.x = THREE.MathUtils.clamp(katamariBody.position.x, -mapBoundary + katamariRadius, mapBoundary - katamariRadius);
            katamariBody.position.z = THREE.MathUtils.clamp(katamariBody.position.z, -mapBoundary + katamariRadius, mapBoundary - katamariRadius);
            katamari.position.copy(katamariBody.position);

            checkCollisions();
            checkMountainCollisions();

            // Dynamic content
            if (katamari.position.distanceTo(lastGenerationPosition) > generationDistanceThreshold) {
                createCollectibleItems(50, currentTheme.items, katamari.position, 150);
                lastGenerationPosition.copy(katamari.position);
            }
            cleanupOldItems();

            updateCamera(smoothedSpeed);
            renderer.render(scene, camera);
            updateUI();
            checkWinCondition();
        }

        // --- ANIMATE HELPERS ---
        function updateItemFading() {
            itemsToCollect.forEach(item => {
                if (item.userData.isFadingIn) {
                    const progress = Math.min(1, (Date.now() - item.userData.fadeStartTime) / itemFadeDuration);
                    const applyOpacity = (obj) => { if (obj.isMesh && obj.material.transparent) obj.material.opacity = progress; };
                    item.traverse(applyOpacity);
                    if (progress === 1) item.userData.isFadingIn = false;
                }
            });
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.age += deltaTime;
                p.userData.velocity.y -= 9.82 * deltaTime;
                p.position.addScaledVector(p.userData.velocity, deltaTime);
                p.material.opacity = 1 - (p.userData.age / p.userData.lifespan);
                if (p.userData.age >= p.userData.lifespan || p.position.y < 0) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    particles.splice(i, 1);
                }
            }
        }

        function updateKatamariMovement(deltaTime) {
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;
            cameraDirection.normalize();
            const rightDirection = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), cameraDirection).normalize();
            let desiredVelocity = new CANNON.Vec3(0,0,0);
            let isMoving = false;

            if (useGyroscope) {
                const fwd = THREE.MathUtils.clamp(gyro.gamma / 45, -1, 1) * gyroSensitivity;
                const side = THREE.MathUtils.lerp(0, -1, THREE.MathUtils.clamp(gyro.beta / 45, -1, 1)) * gyroSensitivity;
                desiredVelocity.x += (cameraDirection.x * fwd - rightDirection.x * side) * moveSpeed;
                desiredVelocity.z += (cameraDirection.z * fwd - rightDirection.z * side) * moveSpeed;
                if (Math.abs(fwd) > 0.1 || Math.abs(side) > 0.1) isMoving = true;
            } else {
                if (keys['w'] || keys['arrowup']) { desiredVelocity.x += cameraDirection.x * moveSpeed; desiredVelocity.z += cameraDirection.z * moveSpeed; isMoving = true; }
                if (keys['s'] || keys['arrowdown']) { desiredVelocity.x -= cameraDirection.x * moveSpeed; desiredVelocity.z -= cameraDirection.z * moveSpeed; isMoving = true; }
                if (keys['a'] || keys['arrowleft']) { desiredVelocity.x -= rightDirection.x * moveSpeed; desiredVelocity.z -= rightDirection.z * moveSpeed; isMoving = true; }
                if (keys['d'] || keys['arrowright']) { desiredVelocity.x += rightDirection.x * moveSpeed; desiredVelocity.z += rightDirection.z * moveSpeed; isMoving = true; }
                if (touchInput.active) {
                    const dx = touchInput.currentX - touchInput.startX, dy = touchInput.currentY - touchInput.startY;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if (len > touchDeadZone) {
                        const nx = dx/len, ny = dy/len;
                        desiredVelocity.x += (cameraDirection.x * ny - rightDirection.x * nx) * moveSpeed * touchSensitivity;
                        desiredVelocity.z += (cameraDirection.z * ny - rightDirection.z * nx) * moveSpeed * touchSensitivity;
                        isMoving = true;
                    }
                }
            }

            if (isMoving) {
                katamariBody.velocity.set(desiredVelocity.x, katamariBody.velocity.y, desiredVelocity.z);
            }

            const currentVelocity = katamariBody.velocity.length();
            if (currentVelocity > 0.1) {
                const up = new CANNON.Vec3(0,1,0);
                const targetAngular = katamariBody.velocity.cross(up);
                targetAngular.scale(1 / katamariRadius, targetAngular);
                const factor = THREE.MathUtils.lerp(0.5, 0.1, Math.min(1, currentVelocity / 5));
                katamariBody.angularVelocity.lerp(targetAngular, factor, katamariBody.angularVelocity);
                playRollingSound(currentVelocity);
            } else {
                stopRollingSound();
                katamariBody.angularVelocity.lerp(new CANNON.Vec3(0,0,0), 0.1, katamariBody.angularVelocity);
            }
            smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, currentVelocity, 0.1);
        }
        
        function updateWobble(deltaTime) {
            if (wobble.active) {
                wobble.time += deltaTime;
                const core = katamari.getObjectByName('core');
                if (core) {
                    const wobbleFactor = 1 + Math.sin(wobble.time / wobble.duration * Math.PI * 2) * wobble.magnitude * (1 - wobble.time / wobble.duration);
                    core.scale.setScalar(wobbleFactor);
                }
                if (wobble.time >= wobble.duration) {
                    wobble.active = false;
                    if (core) core.scale.setScalar(1);
                }
            }
        }

        function updateUI() {
            katamariSizeUI.textContent = `${katamariRadius.toFixed(2)}m`;
            katamariSpeedUI.textContent = `${smoothedSpeed.toFixed(2)}m/s`;
            progressBar.style.width = `${Math.min(100, (katamariRadius / targetKatamariSize) * 100)}%`;
        }

        function checkWinCondition() {
            if (katamariRadius >= targetKatamariSize && messageOverlay.style.display === 'none') {
                messageOverlay.textContent = `LEVEL ${currentLevel} COMPLETE! A magnificent new star! Click to continue.`;
                messageOverlay.style.display = 'flex';
                stopRollingSound();
                currentLevel++;
            }
        }

        // --- GAME LOGIC & COLLISIONS ---
        function cleanupOldItems() {
            for (let i = itemsToCollect.length - 1; i >= 0; i--) {
                const item = itemsToCollect[i];
                if (katamari.position.distanceTo(item.position) > cleanupDistanceThreshold) {
                    const body = physicsBodies.find(b => b.userData?.threeMesh === item);
                    if (body) {
                        world.removeBody(body);
                        physicsBodies = physicsBodies.filter(b => b !== body);
                    }
                    scene.remove(item);
                    itemsToCollect.splice(i, 1);
                }
            }
        }

        function checkCollisions() {
            const katamariSphere = new THREE.Sphere(katamari.position, katamariRadius);
            const collectionThreshold = 1.5;

            for (let i = itemsToCollect.length - 1; i >= 0; i--) {
                const item = itemsToCollect[i];
                const itemBody = physicsBodies.find(b => b.userData?.threeMesh === item);
                if (!itemBody) continue;

                const itemSphere = new THREE.Sphere(item.position, item.userData.size / 2);
                if (katamariSphere.intersectsSphere(itemSphere)) {
                    if (item.userData.size < katamariRadius / collectionThreshold) {
                        attachItem(item, itemBody);
                        playCollectionSound();
                    } else {
                        playBumpSound();
                    }
                }
            }
        }

        function checkMountainCollisions() {
            const now = Date.now();
            mountains.forEach(mountain => {
                if (!mountain.userData.size) return; // Skip clouds
                const mountainCenter = mountain.position.clone();
                mountainCenter.y = katamariBody.position.y;
                const distance = katamariBody.position.distanceTo(mountainCenter);
                
                if (katamariRadius < mountain.userData.minSizeToPass && distance < katamariRadius + mountain.userData.size) {
                    const overlap = (katamariRadius + mountain.userData.size) - distance;
                    if (overlap > 0) {
                        const impulseStrength = moveSpeed * 0.5 * (mountain.userData.size / katamariRadius);
                        const normal = katamariBody.position.vsub(mountainCenter).unit();
                        normal.scale(impulseStrength, normal);
                        normal.y += impulseStrength * 0.05;
                        katamariBody.velocity.x += normal.x;
                        katamariBody.velocity.y += normal.y;
                        katamariBody.velocity.z += normal.z;

                        if (now - lastShedTime > shedCooldown) {
                            shedSound.triggerAttackRelease("C2", "8n");
                            shedItems(Math.max(1, Math.min(3, Math.floor(itemsCollectedCount * 0.1))));
                            lastShedTime = now;
                        }
                    }
                }
            });
        }

        function createParticles(position, color, type) {
            const num = type === 'shed' ? 15 : 10;
            const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
            for (let i = 0; i < num; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mat.clone());
                p.position.copy(position);
                const speed = type === 'shed' ? Math.random() * 5 + 3 : Math.random() * 2 + 1;
                p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*speed, Math.random()*3+1, (Math.random()-0.5)*speed);
                p.userData.lifespan = Math.random() * 0.8 + 0.4;
                p.userData.age = 0;
                scene.add(p);
                particles.push(p);
            }
        }

        function growKatamari(itemSize) {
            katamariRadius += itemSize * 0.05;
            const scale = katamariRadius / 2;
            katamari.scale.setScalar(scale);
            katamariBody.shapes[0].radius = katamariRadius;
        }

        function shedItems(numToShed) {
            const attached = katamari.children.filter(c => c.name !== 'core');
            if (attached.length === 0) return;
            attached.sort(() => 0.5 - Math.random());
            const toShed = Math.min(numToShed, attached.length);

            for (let i = 0; i < toShed; i++) {
                const item = attached[i];
                const worldPos = new THREE.Vector3();
                const worldQuat = new THREE.Quaternion();
                item.getWorldPosition(worldPos);
                item.getWorldQuaternion(worldQuat);

                katamari.remove(item);
                scene.add(item);
                item.traverse(obj => { if(obj.isMesh) { obj.material.opacity = 1; obj.material.transparent = false; }});

                const newBody = new CANNON.Body({ mass: item.userData.size * 5, shape: item.userData.cannonShape });
                newBody.position.copy(worldPos);
                newBody.quaternion.copy(worldQuat);
                newBody.userData = { threeMesh: item };
                world.addBody(newBody);
                physicsBodies.push(newBody);

                const impulseDir = newBody.position.vsub(katamariBody.position).unit();
                impulseDir.scale(20, impulseDir);
                newBody.applyImpulse(impulseDir, newBody.position);

                createParticles(worldPos, item.isGroup ? item.children[0].material.color : item.material.color, 'shed');

                katamariRadius = Math.max(2, katamariRadius - item.userData.size * 0.05);
                itemsCollectedCount--;
            }
            itemsCollectedUI.textContent = itemsCollectedCount;
            const scale = katamariRadius / 2;
            katamari.scale.setScalar(scale);
            katamariBody.shapes[0].radius = katamariRadius;
        }

        function attachItem(item, body) {
            world.removeBody(body);
            physicsBodies = physicsBodies.filter(b => b !== body);
            itemsToCollect = itemsToCollect.filter(i => i !== item);
            itemsCollectedCount++;
            itemsCollectedUI.textContent = itemsCollectedCount;

            const worldPos = new THREE.Vector3();
            item.getWorldPosition(worldPos);
            const dir = worldPos.sub(katamari.position).normalize();
            
            katamari.attach(item);
            item.position.copy(dir.multiplyScalar(katamariRadius));
            
            const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            targetQuat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI * 2));
            item.quaternion.copy(targetQuat.premultiply(katamari.quaternion.clone().invert()));

            growKatamari(item.userData.size);
            wobble.active = true;
            wobble.time = 0;
            createParticles(worldPos, item.isGroup ? item.children[0].material.color : item.material.color, 'collect');
        }

        // --- AUDIO ---
        function playRollingSound(speed) {
            if (rollingSynth.state !== 'started') rollingSynth.triggerAttack(Tone.now());
            const normSpeed = Math.min(1, speed / 20);
            rollingSynth.volume.value = THREE.MathUtils.lerp(-45, -25, normSpeed); // Lowered volume range
            rollingSynth.noise.playbackRate = 0.2 + normSpeed * 1.2; // Adjusted playback rate
        }
        function stopRollingSound() { if (rollingSynth && rollingSynth.state === 'started') rollingSynth.triggerRelease(Tone.now()); }
        function playCollectionSound() {
            const now = Tone.now();
            if (now - lastCollectionSoundTime > collectionSoundCooldown) {
                collectionSynth.triggerAttackRelease("C5", "8n", now);
                lastCollectionSoundTime = now;
            }
        }
        function playBumpSound() {
            const now = Tone.now();
            if (now - lastBumpSoundTime > bumpSoundCooldown) {
                bumpSynth.triggerAttackRelease("C3", "8n", now);
                lastBumpSoundTime = now;
            }
        }

        // --- CAMERA ---
        function updateCamera(speed) {
            const offset = new THREE.Vector3(0, 10 + katamariRadius * 1.5, 15 + katamariRadius * 2.5);
            const desiredPos = katamari.position.clone().add(offset);
            camera.position.lerp(desiredPos, 0.05);
            camera.lookAt(katamari.position); 
            camera.fov = THREE.MathUtils.lerp(70, 90, Math.min(1, speed / 20));
            camera.updateProjectionMatrix();
        }

        // --- START ---
        window.onload = init;
    </script>
</body>
</html>