<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Katamari World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            /* Prevent text selection on touch devices */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevent browser touch gestures like pull-to-refresh */
        }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none; /* Hidden by default, shown when loading */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2.5em;
            z-index: 100;
            text-align: center; /* Ensure text is centered within the flex item */
            text-shadow: 0 0 15px rgba(255,255,255,0.8);
            animation: pulse 2s infinite alternate;
        }
        @keyframes pulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1em;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #progress-container {
            width: 200px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            border-radius: 10px;
            transition: width 0.1s ease-out;
        }
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 2em;
            font-weight: bold;
            color: #FFD700;
            display: none; /* Hidden by default, shown on win */
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            cursor: pointer; /* Indicate it's clickable to restart */
        }
        #controls-info {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            color: #ccc;
            z-index: 10;
            text-align: center;
        }
        #gyro-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            transition: background-color 0.2s ease;
            display: none; /* Hidden by default, shown only on mobile */
        }
        #gyro-button:hover {
            background-color: #0056b3;
        }
        #gyro-button.active {
            background-color: #28a745;
        }
        #gyro-button.active:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Generating a new universe... ✨</div>
    <div id="game-ui">
        <div>Size: <span id="katamari-size">2.00m</span></div>
        <div>Speed: <span id="katamari-speed">0.00m/s</span></div>
        <div>Items Collected: <span id="items-collected">0</span></div>
        <div>FPS: <span id="fps">--</span></div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <div>Target Size: <span id="target-size">100.00m</span></div>
        <div id="power-up-status"></div>
        <button id="gyro-button">Toggle Gyro</button>
    </div>
    <div id="controls-info">
        <p>Use <b>W, A, S, D</b> or <b>Arrow Keys</b> to move the Katamari.</p>
        <p><b>Swipe</b> on screen for precise mobile control.</p>
        <p><b>Toggle Gyro</b> for tilt-based movement on supported devices.</p>
        <p>Press <b>R</b> to reset Katamari position. Press <b>Space</b> to generate a new world.</p>
    </div>
    <div id="message-overlay"></div>

    <!-- Three.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <!-- Tone.js Library for Audio Synthesis (Loaded globally) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    

    <script type="module">
        // Cannon-ES Library for Physics (Moved to top-level of module script)
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js';

        // Encapsulate the entire game logic within an IIFE to prevent global variable re-declaration errors.
        const gameModule = (function() { // Assign the IIFE's return value to gameModule
            // --- SCENE/PHYSICS SETUP ---
            let scene, camera, renderer, world;
            let katamari, ground, groundBody, suckingEffect;
            let itemsToCollect = [], physicsBodies = []; // physicsBodies will now only store item bodies
            let mountains = []; // Array to store mountain objects
            let katamariRadius = 2, targetKatamariSize = 100, itemsCollectedCount = 0, targetRadius = 2;
            let cameraLookAtTarget = new THREE.Vector3();
            let rollingSynth, collectionSynth, shedSound, attractionHum; // Tone.js synthesizers
            const keys = {}, clock = new THREE.Clock();
            // moveSpeed for direct Three.js movement, damping for item physics
            let timeStep = 1 / 60; 
            let currentLevel = 1;
            let isGeneratingLevel = false; // Flag to prevent physics updates during level generation
            let smoothedSpeed = 0; // New variable for smoothing camera FOV changes
            let currentTheme; // Store the current theme to regenerate items

            // Cooldowns
            let lastCollectionSoundTime = 0;
            const collectionSoundCooldown = 0.05; // 0.05 seconds cooldown
            let lastShedTime = 0; // New variable to track last shed time
            const shedCooldown = 1000; // 1 second cooldown for shedding items

            const baseSuckRangeFactor = 1.5; // Base suck range factor for Katamari
            let currentSuckRange = 0; // Declare suckRange at a higher scope

            // Dynamic item generation variables
            let lastGenerationPosition = new THREE.Vector3();
            const generationDistanceThreshold = 50; // Generate new items every 50 units of travel
            const cleanupDistanceThreshold = 200; // Remove items beyond 200 units from Katamari
            const mapBoundary = 240; // Max X and Z coordinate for item generation to stay on map
            const physicsActiveDistance = 100; // Distance from Katamari within which physics bodies are always active

            // Item fade-in duration in milliseconds
            const itemFadeDuration = 1000; 

            // Global frustum for visibility checks
            const frustum = new THREE.Frustum();

            // Katamari physics body
            let katamariBody;

            // --- Power-up Variables ---
            let activePowerUps = {}; // To store active power-ups and their expiry times
            const powerUpTypes = ['magnetism', 'speedBoost', 'stickyCoating', 'vacuumBoost'];
            const powerUpDuration = 5000; // 5 seconds in milliseconds
            let powerUpItems = []; // To store the visual meshes of power-up items

            // Particles array
            let particles = [];

            // --- Touch Input Variables ---
            const touchInput = {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                active: false
            };
            // Make touch deadzone screen-size relative
            const touchDeadZone = Math.min(30, window.innerWidth * 0.05); // Smaller deadzone for more responsiveness
            const touchSensitivity = 1.0; // Increased sensitivity for more direct control

            // --- FPS Counter ---
            const fpsCounter = {
                dom: null, // Will be assigned in init
                frames: [],
                lastFrameTimeStamp: performance.now(),
                init: function() {
                    this.dom = document.getElementById('fps');
                },
                update: function() {
                    const now = performance.now();
                    const delta = now - this.lastFrameTimeStamp;
                    this.lastFrameTimeStamp = now;
                    const fps = 1 / (delta / 1000);
                    
                    this.frames.push(fps);
                    if (this.frames.length > 60) {
                        this.frames.shift();
                    }
                    
                    let mean = 0;
                    for(const frame of this.frames) {
                        mean += frame;
                    }
                    mean /= this.frames.length;

                    if (this.dom) {
                        this.dom.textContent = Math.round(mean);
                    }
                }
            };

            // --- Gyroscope Variables ---
            let useGyroscope = false;
            let gyro = { alpha: 0, beta: 0, gamma: 0 }; // Store latest gyro data
            const gyroSensitivity = 0.5; // Adjust for more/less sensitive gyro controls

            // --- UI ELEMENTS ---
            const katamariSizeUI = document.getElementById('katamari-size');
            const katamariSpeedUI = document.getElementById('katamari-speed');
            const itemsCollectedUI = document.getElementById('items-collected');
            const progressBar = document.getElementById('progress-bar');
            const targetSizeUI = document.getElementById('target-size');
            const messageOverlay = document.getElementById('message-overlay');
            const loadingOverlay = document.getElementById('loading-overlay');
            const gyroButton = document.getElementById('gyro-button');

            // --- Instanced Mesh Variables ---
            // Store geometries and materials for instanced meshes
            const instancedGeometries = {};
            const instancedMaterials = {};
            // Store the InstancedMesh objects themselves
            const instancedMeshes = {};
            // Map from item name to a unique ID for instancing
            const instancedItemMap = {
                'Rock': 'rock',
                'Bush': 'bush',
                'Flower': 'flower',
                'Mushroom': 'mushroom',
                'Traffic Cone': 'trafficCone',
                'Garden Gnome': 'gardenGnome',
                'Bird Bath': 'birdBath',
                'Asteroid': 'asteroid',
                'Space Debris': 'spaceDebris',
                'Comet Fragment': 'cometFragment',
                'Moon Rock': 'moonRock',
                'Star Dust Cluster': 'starDustCluster'
            };
            // Max instances per InstancedMesh
            const MAX_INSTANCES = 1000;


            // --- INIT ---
            async function init() {
                fpsCounter.init();

                // Debugging: Check Tone object
                console.log("Tone object after script load:", Tone);
                console.log("Type of Tone.NoiseSynth:", typeof Tone.NoiseSynth);
                console.log("Type of Tone.Synth:", typeof Tone.Synth);
                console.log("Type of Tone.MembraneSynth:", typeof Tone.MembraneSynth);
                // Debugging: Check CANNON object
                console.log("CANNON object after module import:", CANNON);
                console.log("Type of CANNON.World:", typeof CANNON.World);


                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 15, 30);
                camera.lookAt(0, 0, 0);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // Physics world setup (using CANNON from cannon-es)
                world = new CANNON.World();
                world.gravity.set(0, -20, 0); // Increased gravity for faster falling
                world.broadphase = new CANNON.SAPBroadphase(world);
                world.solver = new CANNON.GSSolver();
                world.solver.iterations = 20; // Further increased for stability (especially with large items)
                world.defaultContactMaterial.friction = 1.0;
                world.defaultContactMaterial.restitution = 0; // No bounciness
                world.defaultContactMaterial.contactEquationStiffness = 1e8; // Increased stiffness for more rigid contacts
                world.defaultContactMaterial.contactEquationRelaxation = 2; // Reduced relaxation for faster resolution

                // Lighting
                scene.add(new THREE.AmbientLight(0x404040));
                const hemiLight = new THREE.HemisphereLight(0xADD8E6, 0x8B4513, 0.8);
                scene.add(hemiLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(20, 50, 20);
                dirLight.castShadow = true;
                Object.assign(dirLight.shadow.camera, { top: 50, bottom: -50, left: -50, right: 50 });
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.height = 2048;
                dirLight.shadow.bias = -0.0005;
                scene.add(dirLight);

                // Initialize Tone.js synths
                rollingSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 1, release: 0.1 }
                }).toDestination();
                rollingSynth.volume.value = -30; // Start quiet

                collectionSynth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
                }).toDestination();
                collectionSynth.volume.value = -10; // Default volume for collection sound

                shedSound = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 2,
                    envelope: {
                        attack: 0.001,
                        decay: 0.2,
                        sustain: 0.01,
                        release: 0.2,
                        attackCurve: "exponential"
                    },
                    oscillator: { type: "sine" },
                    volume: -15
                }).toDestination();

                attractionHum = new Tone.Oscillator({
                    frequency: 50, // Start at a low frequency
                    type: "sine",
                    volume: -40 // Start very quiet
                }).toDestination();
                attractionHum.start();

                // Keyboard event listeners
                window.addEventListener('keydown', e => {
                    keys[e.key.toLowerCase()] = true;
                    if (e.key.toLowerCase() === ' ') generateNewLevel();
                    else if (e.key.toLowerCase() === 'r') resetKatamariPosition();
                });
                window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
                
                // Touch event listeners for mobile control
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd);

                // Gyroscope button listener
                gyroButton.addEventListener('click', toggleGyroscope);

                // Set up gyroscope button visibility
                setupGyroButtonVisibility();

                window.addEventListener('resize', onWindowResize);
                messageOverlay.addEventListener('click', generateNewLevel); // Click to restart/next level

                console.log("Calling generateNewLevel from init...");
                await generateNewLevel(); // Initial level generation
                console.log("generateNewLevel completed. Starting animation loop.");
                animate(); // Start the game loop
            }

            // --- Touch Input Handlers ---
            function onTouchStart(event) {
                event.preventDefault(); // Prevent scrolling/zooming on the canvas
                touchInput.active = true;
                touchInput.startX = event.touches[0].clientX;
                touchInput.startY = event.touches[0].clientY;
                touchInput.currentX = touchInput.startX;
                touchInput.currentY = touchInput.startY;
            }

            function onTouchMove(event) {
                event.preventDefault(); // Prevent scrolling/zooming on the canvas
                if (touchInput.active) {
                    touchInput.currentX = event.touches[0].clientX;
                    touchInput.currentY = event.touches[0].clientY;
                }
            }

            function onTouchEnd(event) {
                touchInput.active = false;
                // Reset touch input when touch ends
                touchInput.x = 0;
                touchInput.y = 0;
                touchInput.startX = 0;
                touchInput.startY = 0;
                touchInput.currentX = 0;
                touchInput.currentY = 0;
            }

            // --- Gyroscope Control ---
            function handleDeviceOrientation(event) {
                // gamma: -90 to +90 (front-to-back tilt)
                // beta: -180 to +180 (left-to-right tilt)
                // alpha: 0 to 360 (compass direction) - not used for movement
                gyro.gamma = event.gamma;
                gyro.beta = event.beta;
                // Normalize beta and gamma to -1 to 1 range for easier use
                gyro.normalizedGamma = THREE.MathUtils.clamp(event.gamma / 90, -1, 1);
                gyro.normalizedBeta = THREE.MathUtils.clamp(event.beta / 90, -1, 1);
            }

            function toggleGyroscope() {
                if (useGyroscope) {
                    // Turn off gyroscope
                    window.removeEventListener('deviceorientation', handleDeviceOrientation);
                    useGyroscope = false;
                    gyroButton.classList.remove('active');
                    gyroButton.textContent = 'Toggle Gyro';
                    console.log("Gyroscope controls OFF");
                } else {
                    // Request permission for iOS 13+
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                                    useGyroscope = true;
                                    gyroButton.classList.add('active');
                                    gyroButton.textContent = 'Gyro ON';
                                    console.log("Gyroscope controls ON (permission granted)");
                                } else {
                                    console.warn("Permission for device orientation denied.");
                                    alert("Permission for gyroscope was denied. Please allow motion and orientation access in your device settings for gyroscope controls.");
                                }
                            })
                            .catch(error => {
                                console.error("Error requesting device orientation permission:", error);
                                alert("Could not enable gyroscope. Ensure your device supports it and allows motion and orientation access.");
                            });
                    } else {
                        // For non-iOS 13+ devices, just add the listener
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                        useGyroscope = true;
                        gyroButton.classList.add('active');
                        gyroButton.textContent = 'Gyro ON';
                        console.log("Gyroscope controls ON (no permission needed)");
                    }
                }
            }

            // Function to determine if on a mobile device and show/hide gyro button
            function setupGyroButtonVisibility() {
                // Check for touch capability (indicates mobile) AND DeviceOrientationEvent support
                if (window.matchMedia("(pointer: coarse)").matches && window.DeviceOrientationEvent) {
                    gyroButton.style.display = 'block';
                } else {
                    gyroButton.style.display = 'none';
                }
            }


            // --- LEVEL THEMING ---
            async function generateLevelTheme() {
                console.log("Starting generateLevelTheme...");
                loadingOverlay.style.display = 'flex';
                const themes = [
                    {
                        themeName: "Our Green Earth",
                        story: "The King of All Cosmos demands a pristine Earth! Roll up all the litter and grow your Katamari!",
                        items: ["Car", "Tree", "House", "Rock", "Bush", "Bench", "Lamp Post", "Trash Can", "Mailbox", "Mushroom", "Flower", "Garden Gnome", "Bird Bath", "Picnic Table"],
                        groundColor: "#4CAF50", skyColor: "#87CEEB",
                        baseTargetSize: 25 // Base target for this theme
                    },
                    {
                        themeName: "Urban Jungle",
                        story: "The city is a mess! Clean up the streets and grow your Katamari to skyscraper size!",
                        items: ["Car", "Lamp Post", "Trash Can", "Bench", "Mailbox", "Fire Hydrant", "Traffic Cone", "Hot Dog Stand", "Newspaper Stand", "Bicycle", "Skateboard", "Shopping Cart"],
                        groundColor: "#607D8B", skyColor: "#B0C4DE",
                        baseTargetSize: 100 // Base target for this theme
                    },
                    {
                        themeName: "Cosmic Debris",
                        story: "The cosmos is cluttered! Roll up space junk and form a new star!",
                        items: ["Asteroid", "Satellite", "Space Debris", "Comet Fragment", "Moon Rock", "Star Dust Cluster", "Alien Artifact", "Space Probe"],
                        groundColor: "#2C3E50", skyColor: "#0A0A2A",
                        baseTargetSize: 200 // Base target for this theme
                    }
                ];
                const theme = themes[(currentLevel - 1) % themes.length]; // Cycle through themes
                loadingOverlay.textContent = `Generating ${theme.themeName}... ✨`; // Update loading text
                await new Promise(r => setTimeout(r, 1500)); // Simulate loading time
                loadingOverlay.style.display = 'none';
                console.log("Finished generateLevelTheme. Selected theme:", theme.themeName);
                return theme;
            }

            // --- LEVEL CREATION ---
            async function generateNewLevel() {
                console.log("Starting generateNewLevel...");
                isGeneratingLevel = true; // Set flag at the start of level generation
                stopRollingSound();
                messageOverlay.style.display = 'none'; // Hide win message

                // Clean up previous level's objects
                console.log("Cleaning up previous level objects...");
                if (katamari) scene.remove(katamari);
                if (ground) scene.remove(ground);
                
                // Dispose of existing instanced meshes and clear their arrays
                for (const key in instancedMeshes) {
                    if (instancedMeshes[key]) {
                        scene.remove(instancedMeshes[key]);
                        instancedMeshes[key].geometry.dispose();
                        instancedMeshes[key].material.dispose();
                        instancedMeshes[key] = null; // Clear reference
                    }
                }
                // Dispose of shared geometries and materials
                for (const key in instancedGeometries) {
                    if (instancedGeometries[key]) {
                        instancedGeometries[key].dispose();
                        instancedGeometries[key] = null;
                    }
                }
                for (const key in instancedMaterials) {
                    if (instancedMaterials[key]) {
                        instancedMaterials[key].dispose();
                        instancedMaterials[key] = null;
                    }
                }

                itemsToCollect.forEach(item => {
                    // If it's a regular mesh (not instanced), remove it
                    if (!item.userData.isInstanced) {
                        scene.remove(item);
                    }
                });
                powerUpItems.forEach(item => scene.remove(item));
                powerUpItems = [];
                physicsBodies.forEach(body => world.removeBody(body)); // Use world.removeBody for cannon-es
                
                // Re-initialize Cannon.js world for items
                console.log("Re-initializing physics world...");
                world = new CANNON.World();
                world.gravity.set(0, -20, 0); // Increased gravity for faster falling
                world.broadphase = new CANNON.SAPBroadphase(world);
                world.solver = new CANNON.GSSolver();
                world.solver.iterations = 20; // Further increased for stability (especially with large items)
                world.defaultContactMaterial.friction = 1.0;
                world.defaultContactMaterial.restitution = 0; // No bounciness
                world.defaultContactMaterial.contactEquationStiffness = 1e8; // Increased stiffness for more rigid contacts
                world.defaultContactMaterial.contactEquationRelaxation = 2; // Reduced relaxation for faster resolution

                itemsToCollect = [];
                physicsBodies = [];
                mountains = []; // Clear mountains array on new level generation
                itemsCollectedCount = 0;
                itemsCollectedUI.textContent = itemsCollectedCount;

                currentTheme = await generateLevelTheme(); // Store the theme globally
                // Difficulty scaling: target size increases with level
                const difficultyFactor = 1 + (currentLevel - 1) * 0.5; // 0.5x increase per level
                targetKatamariSize = currentTheme.baseTargetSize * difficultyFactor; 
                targetSizeUI.textContent = targetKatamariSize.toFixed(2) + 'm';

                scene.background = new THREE.Color(currentTheme.skyColor);
                scene.fog = new THREE.Fog(currentTheme.skyColor, 50, 200);
                createEnvironment(currentTheme);
                console.log("Environment created.");

                // Ground (still has a Cannon.js body to interact with items)
                console.log("Creating ground...");
                const groundColor1 = new THREE.Color(currentTheme.groundColor);
                const groundColor2 = groundColor1.clone().lerp(new THREE.Color(0x000000), 0.1); // Slightly darker variant
                const groundTexture = generateGroundTexture(groundColor1, groundColor2);
                const groundMat = new THREE.MeshLambertMaterial({ map: groundTexture });

                const groundGeo = new THREE.PlaneGeometry(500, 500); // Larger ground
                ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(new CANNON.Plane());
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                world.addBody(groundBody); // Use world.addBody for cannon-es
                console.log("Ground created and added to physics world.");

                // Katamari (now purely a Three.js object for movement)
                console.log("Creating Katamari...");
                katamariRadius = 2; // Reset radius for new level
                katamari = new THREE.Group();
                const katGeo = new THREE.SphereGeometry(katamariRadius, 32, 32);
                const katamariTexture = new THREE.CanvasTexture(generateKatamariTexture());
                const katMat = new THREE.MeshStandardMaterial({
                    map: katamariTexture, roughness: 0.6, metalness: 0.1
                });
                const katamariBall = new THREE.Mesh(katGeo, katMat);
                katamariBall.castShadow = true;
                katamariBall.name = 'core';
                katamari.add(katamariBall);
                katamari.position.y = katamariRadius; // Keep it on the ground
                katamari.scale.set(1, 1, 1); // Initial scale
                scene.add(katamari);
                suckingEffect = createSuckingEffect();
                cameraLookAtTarget.copy(katamari.position);
                cameraLookAtTarget.copy(katamari.position);
                
                // Create Katamari physics body
                const katamariShape = new CANNON.Sphere(katamariRadius);
                katamariBody = new CANNON.Body({
                    mass: 100, // High mass so it doesn't move easily by collisions
                    position: new CANNON.Vec3(0, katamariRadius, 0),
                    shape: katamariShape,
                    linearDamping: 0.05, // Reduced linear damping for more natural momentum
                    angularDamping: 0.05, // Reduced angular damping for more natural momentum
                    
                });
                katamariBody.addEventListener('collide', handleKatamariCollision);
                world.addBody(katamariBody); // Use world.addBody for cannon-es
                updateKatamariPhysics(); // Initial physics update for Katamari
                console.log("Katamari created and added to physics world.");

                lastGenerationPosition.copy(katamari.position); // Initialize generation position
                console.log("Creating initial collectible items...");
                createCollectibleItems(200, currentTheme.items, new THREE.Vector3(0,0,0), 180); // Initial generation around origin (reduced count)
                createPowerUpItems(5); // Create 5 power-ups
                console.log("Initial collectible items created.");
                isGeneratingLevel = false; // Clear flag after level generation is complete
                console.log("generateNewLevel finished.");
            }

            function createEnvironment(theme) {
                console.log("createEnvironment: Removing old environment objects...");
                // Remove old environment objects
                scene.children.filter(obj => obj.userData.isEnvironment).forEach(obj => scene.remove(obj));
                mountains = []; // Ensure mountains array is cleared
                console.log("createEnvironment: Old environment objects removed.");

                // Clouds
                console.log("createEnvironment: Creating clouds...");
                const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, roughness: 1 });
                for (let i = 0; i < 15; i++) {
                    const cloudGeo = new THREE.SphereGeometry(Math.random() * 8 + 5, 16, 16);
                    const cloud = new THREE.Mesh(cloudGeo, cloudMat);
                    cloud.position.set((Math.random() - 0.5) * 400, 50 + Math.random() * 30, (Math.random() - 0.5) * 400);
                    cloud.userData.isEnvironment = true;
                    scene.add(cloud);
                }
                console.log("createEnvironment: Clouds created.");

                // Mountains (or other distant scenery based on theme)
                console.log("createEnvironment: Creating mountains...");
                const mountainColor = new THREE.Color(theme.groundColor).lerp(new THREE.Color(0x000000), 0.2);
                const mountainMat = new THREE.MeshStandardMaterial({ color: mountainColor, roughness: 0.8 });
                const safeZoneRadius = 50; // Define a radius around the origin where mountains shouldn't spawn

                for (let i = 0; i < 8; i++) {
                    const h = Math.random() * 50 + 30, r = Math.random() * 40 + 20;
                    const mountainGeo = new THREE.ConeGeometry(r, h, 16);
                    const mountain = new THREE.Mesh(mountainGeo, mountainMat);
                    mountain.castShadow = mountain.receiveShadow = true;
                    mountain.userData.isEnvironment = true;
                    mountain.userData.size = r; // Store the effective radius for collision
                    mountain.userData.minSizeToPass = r * 1.8; // Katamari must be at least 1.8x mountain radius to pass

                    let xPos, zPos;
                    let positionFound = false;
                    // Try to find a position outside the safe zone
                    while (!positionFound) {
                        xPos = (Math.random() - 0.5) * 500;
                        zPos = (Math.random() - 0.5) * 500;
                        // Check if the mountain's base is outside the safe zone
                        if (Math.sqrt(xPos * xPos + zPos * zPos) > safeZoneRadius) {
                            positionFound = true;
                        }
                    }
                    mountain.position.set(xPos, h / 2 - 0.1, zPos);
                    scene.add(mountain);
                    mountains.push(mountain); // Add to new mountains array
                }
                console.log("createEnvironment: Mountains created.");
            }

            function generateKatamariTexture() {
                const canvas = document.createElement('canvas');
                const size = 256;
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Clear canvas
                ctx.clearRect(0, 0, size, size);

                // Background color for the Katamari (a base color)
                ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 50%)`;
                ctx.fillRect(0, 0, size, size);

                // Draw random "patches" to simulate collected items
                const numPatches = 100 + Math.random() * 100;
                for (let i = 0; i < numPatches; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const patchSize = 10 + Math.random() * 30; // Size of each patch
                    const shapeType = Math.random();

                    // Random vibrant color for the patch
                    ctx.fillStyle = `hsl(${Math.random() * 360}, 90%, ${50 + Math.random() * 20}%)`;
                    ctx.globalAlpha = 0.7 + Math.random() * 0.3; // Vary opacity

                    ctx.beginPath();
                    if (shapeType < 0.5) {
                        // Draw a rectangle
                        ctx.fillRect(x, y, patchSize, patchSize);
                    } else {
                        // Draw a circle
                        ctx.arc(x, y, patchSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                ctx.globalAlpha = 1; // Reset alpha

                return canvas;
            }

            // New function to generate a repeating ground texture
            function generateGroundTexture(color1, color2) {
                const canvas = document.createElement('canvas');
                const size = 128; // Smaller texture for tiling
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Create a more varied, less uniform ground texture
                for (let x = 0; x < size; x++) {
                    for (let y = 0; y < size; y++) { 
                        // Perlin-like noise for smoother transitions
                        const noiseVal = Math.sin(x * 0.1) * 0.5 + Math.cos(y * 0.1) * 0.5 + 1; // 0 to 2
                        const blend = (noiseVal / 2) * 0.4 + 0.6; // Blend factor between 0.6 and 1.0
                        
                        const r = Math.floor(color1.r * 255 * blend + color2.r * 255 * (1 - blend));
                        const g = Math.floor(color1.g * 255 * blend + color2.g * 255 * (1 - blend));
                        const b = Math.floor(color1.b * 255 * blend + color2.b * 255 * (1 - blend));
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(50, 50); // Repeat many times over the large ground plane
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Improve texture quality at oblique angles
                return texture;
            }

            // Modified createCollectibleItems to spawn around a center position
            function createCollectibleItems(count, itemNames, centerPosition = new THREE.Vector3(0,0,0), spawnRadius = 100) {
                console.log(`createCollectibleItems: Attempting to create ${count} items.`);
                if (!itemNames || itemNames.length === 0) {
                    console.warn("createCollectibleItems: itemNames array is empty or undefined. Cannot create items.");
                    return;
                }
                // Updated item colors to be more vibrant and diverse
                const itemColors = [0xFF6347, 0x6A5ACD, 0x3CB371, 0xFFD700, 0xBA55D3, 0x4682B4, 0xD2B48C, 0xFFA07A, 0x20B2AA, 0xFF69B4];
                
                // Initialize instanced meshes if they don't exist
                for (const itemName in instancedItemMap) {
                    const id = instancedItemMap[itemName];
                    if (!instancedMeshes[id]) {
                        let geometry, material;
                        const color = itemColors[Math.floor(Math.random() * itemColors.length)];
                        const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, transparent: true, opacity: 0 });

                        switch (itemName) {
                            case 'Rock':
                                geometry = new THREE.SphereGeometry(0.7, 16, 16);
                                break;
                            case 'Bush':
                                geometry = new THREE.SphereGeometry(0.8, 24, 24);
                                break;
                            case 'Flower':
                                // For complex instanced items, you might need a simplified geometry
                                geometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8); // Simplified flower
                                break;
                            case 'Mushroom':
                                geometry = new THREE.CylinderGeometry(0.6, 0.3, 1.2, 16); // Simplified mushroom
                                break;
                            case 'Traffic Cone':
                                geometry = new THREE.ConeGeometry(0.5, 1.5, 16);
                                break;
                            case 'Garden Gnome':
                                geometry = new THREE.SphereGeometry(0.5, 16, 16); // Simplified gnome
                                break;
                            case 'Bird Bath':
                                geometry = new THREE.CylinderGeometry(0.7, 0.6, 1.4, 16); // Simplified bird bath
                                break;
                            case 'Asteroid':
                                geometry = new THREE.IcosahedronGeometry(1, 0); // Base size for asteroid
                                break;
                            case 'Space Debris':
                                geometry = new THREE.BoxGeometry(1, 1, 1); // Generic debris
                                break;
                            case 'Comet Fragment':
                                geometry = new THREE.IcosahedronGeometry(1, 1);
                                break;
                            case 'Moon Rock':
                                geometry = new THREE.DodecahedronGeometry(1, 0);
                                break;
                            case 'Star Dust Cluster':
                                geometry = new THREE.SphereGeometry(0.5, 8, 8); // Simplified star dust
                                break;
                            default:
                                continue; // Skip items not meant for instancing
                        }
                        instancedGeometries[id] = geometry;
                        instancedMaterials[id] = mat;
                        instancedMeshes[id] = new THREE.InstancedMesh(geometry, mat, MAX_INSTANCES);
                        instancedMeshes[id].instanceMatrix.setUsage(THREE.DynamicDrawUsage); // Will be updated frequently
                        instancedMeshes[id].castShadow = true;
                        instancedMeshes[id].receiveShadow = true;
                        scene.add(instancedMeshes[id]);
                    }
                }

                const dummy = new THREE.Object3D(); // For setting instance matrix

                for (let i = 0; i < count; i++) {
                    const itemName = itemNames[Math.floor(Math.random() * itemNames.length)];
                    console.log(`Attempting to create item: ${itemName}`); 
                    
                    let threeMesh; // This will either be a regular Mesh or an InstancedMesh instance
                    let cannonShape;
                    let size; // Effective size for collection

                    const color = itemColors[Math.floor(Math.random() * itemColors.length)];

                    // Check if the item can be instanced
                    const instancedId = instancedItemMap[itemName];
                    const isInstanced = !!instancedId;

                    if (isInstanced) {
                        // For instanced items, size will be applied via scale
                        size = Math.random() * 1.5 + 0.5; // Shared size range for instanced items
                        const baseGeometry = instancedGeometries[instancedId];
                        
                        // Determine cannon shape based on the base geometry type
                        if (baseGeometry.type === 'SphereGeometry' || baseGeometry.type === 'IcosahedronGeometry' || baseGeometry.type === 'DodecahedronGeometry') {
                            cannonShape = new CANNON.Sphere(size * baseGeometry.parameters.radius);
                        } else if (baseGeometry.type === 'BoxGeometry') {
                            cannonShape = new CANNON.Box(new CANNON.Vec3(size * baseGeometry.parameters.width * 0.5, size * baseGeometry.parameters.height * 0.5, size * baseGeometry.parameters.depth * 0.5));
                        } else if (baseGeometry.type === 'CylinderGeometry') {
                            cannonShape = new CANNON.Cylinder(size * baseGeometry.parameters.radiusTop, size * baseGeometry.parameters.radiusBottom, size * baseGeometry.parameters.height, baseGeometry.parameters.radialSegments);
                        } else if (baseGeometry.type === 'ConeGeometry') {
                            cannonShape = new CANNON.Cylinder(0, size * baseGeometry.parameters.radius, size * baseGeometry.parameters.height, baseGeometry.parameters.radialSegments);
                        } else {
                            // Fallback for complex or unknown instanced geometries
                            cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.5, size * 0.5, size * 0.5));
                        }

                        // Create a dummy mesh to represent the instance for physics and user data
                        threeMesh = new THREE.Mesh(); // A placeholder mesh
                        threeMesh.userData.isInstanced = true;
                        threeMesh.userData.instancedId = instancedId;
                        threeMesh.userData.instanceIndex = -1; // Will be set when added to InstancedMesh
                        threeMesh.userData.size = size * (baseGeometry.parameters.radius || baseGeometry.parameters.height || baseGeometry.parameters.width); // Effective size
                        threeMesh.userData.cannonShape = cannonShape; // Store Cannon.js shape
                        threeMesh.userData.color = color; // Store color for fade-in

                    } else {
                        // Existing non-instanced item creation logic
                        let itemGroup = new THREE.Group(); // Still needed for grouped items
                        threeMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x888888, transparent: true, opacity: 0 })); // Default
                        threeMesh.userData.size = 1;

                        switch (itemName) {
                            case 'Car': // Medium (effective size 1.6m - 5.6m)
                                size = Math.random() * 2 + 0.8;
                                // Main body
                                const carBodyGeo = new THREE.BoxGeometry(size * 2, size * 0.8, size);
                                const carBodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, transparent: true, opacity: 0 });
                                const carBody = new THREE.Mesh(carBodyGeo, carBodyMat);
                                carBody.castShadow = carBody.receiveShadow = true; itemGroup.add(carBody);

                                // Cabin
                                const carCabinGeo = new THREE.BoxGeometry(size * 1.2, size * 0.6, size * 0.8);
                                const carCabinMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, transparent: true, opacity: 0 });
                                const carCabin = new THREE.Mesh(carCabinGeo, carCabinMat);
                                carCabin.castShadow = carCabin.receiveShadow = true; carCabin.position.y = size * 0.7; itemGroup.add(carCabin);

                                // Windshields (front and back)
                                const windshieldMat = new THREE.MeshStandardMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.7 });
                                const frontWindshield = new THREE.Mesh(new THREE.PlaneGeometry(size * 1.1, size * 0.4), windshieldMat);
                                frontWindshield.position.set(0, size * 0.8, size * 0.4); itemGroup.add(frontWindshield);
                                const backWindshield = new THREE.Mesh(new THREE.PlaneGeometry(size * 1.1, size * 0.4), windshieldMat);
                                backWindshield.position.set(0, size * 0.8, -size * 0.4); backWindshield.rotation.y = Math.PI; itemGroup.add(backWindshield);

                                // Wheels
                                const wheelGeo = new THREE.CylinderGeometry(size * 0.25, size * 0.25, size * 0.2, 16);
                                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, transparent: true, opacity: 0 });
                                for (const [dx, dz] of [[0.7, 0.5],[ -0.7, 0.5],[0.7, -0.5],[ -0.7, -0.5]]) {
                                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                                    wheel.rotation.z = Math.PI / 2;
                                    wheel.position.set(size * dx, -size * 0.2, size * dz);
                                    itemGroup.add(wheel);
                                }
                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 2; // Effective size for collection
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size, size * 0.4, size * 0.5));
                                break;

                            case 'Tree': // Small/Medium (effective size 0.6m - 9m depending on type)
                                // Randomly select a tree type
                                const treeType = Math.random();
                                if (treeType < 0.33) { // Tall and slender tree
                                    size = Math.random() * 4 + 2; // Larger size range
                                    // Trunk
                                    const trunkGeo = new THREE.CylinderGeometry(size * 0.08, size * 0.12, size * 1.2, 8);
                                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                                    trunk.castShadow = trunk.receiveShadow = true;
                                    trunk.position.y = size * 0.6; itemGroup.add(trunk);

                                    // Foliage (cone shape for a pine-like tree)
                                    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.5, transparent: true, opacity: 0 });
                                    const foliageGeo = new THREE.ConeGeometry(size * 0.4, size * 0.8, 16);
                                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                                    foliage.castShadow = foliage.receiveShadow = true;
                                    foliage.position.y = size * 1.2; itemGroup.add(foliage);

                                    threeMesh = itemGroup;
                                    threeMesh.userData.size = size * 1.5;
                                    cannonShape = new CANNON.Cylinder(size * 0.12, size * 0.4, size * 2, 8); // Adjusted for taller shape
                                } else if (treeType < 0.66) { // Bushy tree
                                    size = Math.random() * 2 + 1; // Medium size range
                                    // Trunk (shorter, wider)
                                    const trunkGeo = new THREE.CylinderGeometry(size * 0.15, size * 0.2, size * 0.5, 8);
                                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                                    trunk.castShadow = trunk.receiveShadow = true;
                                    trunk.position.y = size * 0.25; itemGroup.add(trunk);

                                    // Foliage (multiple larger spheres for a bushy look)
                                    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.5, transparent: true, opacity: 0 });
                                    for (let j = 0, n = 4 + Math.floor(Math.random() * 3); j < n; j++) {
                                        const sphereSize = size * (0.4 + Math.random() * 0.3);
                                        const foliageGeo = new THREE.SphereGeometry(sphereSize, 16, 16);
                                        const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                                        foliage.castShadow = foliage.receiveShadow = true;
                                        foliage.position.set((Math.random() - 0.5) * size * 0.8, size * 0.5 + (Math.random() * size * 0.5),
                                            (Math.random() - 0.5) * size * 0.8);
                                        itemGroup.add(foliage);
                                    }
                                    threeMesh = itemGroup;
                                    threeMesh.userData.size = size * 1.8; // Larger effective size
                                    cannonShape = new CANNON.Sphere(size * 0.9); // Approximate with a larger sphere
                                } else { // Small sapling / shrub
                                    size = Math.random() * 1 + 0.5; // Smaller size range
                                    // Trunk (very small)
                                    const trunkGeo = new THREE.CylinderGeometry(size * 0.05, size * 0.08, size * 0.3, 6);
                                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                                    trunk.castShadow = trunk.receiveShadow = true;
                                    trunk.position.y = size * 0.15; itemGroup.add(trunk);

                                    // Foliage (single, slightly irregular sphere)
                                    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.5, transparent: true, opacity: 0 });
                                    const foliageGeo = new THREE.SphereGeometry(size * 0.6, 12, 12);
                                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                                    foliage.castShadow = foliage.receiveShadow = true;
                                    foliage.position.y = size * 0.5; itemGroup.add(foliage);

                                    threeMesh = itemGroup;
                                    threeMesh.userData.size = size * 1.2; // Smaller effective size
                                    cannonShape = new CANNON.Sphere(size * 0.6); // Approximate with a sphere
                                }
                                break;

                            case 'House': // Small/Medium (effective size 1.5m - 4.5m)
                                size = Math.random() * 2 + 1;
                                itemGroup = new THREE.Group();
                                // Main body
                                const mainBodyGeo = new THREE.BoxGeometry(size * 1.5, size * 1.2, size * 1.5);
                                const mainBodyMat = new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.7, transparent: true, opacity: 0 });
                                const mainBody = new THREE.Mesh(mainBodyGeo, mainBodyMat);
                                mainBody.castShadow = mainBody.receiveShadow = true; itemGroup.add(mainBody);

                                // Roof (pyramid shape)
                                const roofGeo = new THREE.ConeGeometry(size * 1.2, size * 0.8, 4);
                                const roofMat = new THREE.MeshStandardMaterial({ color: 0xA0522D, roughness: 0.7, transparent: true, opacity: 0 });
                                const roof = new THREE.Mesh(roofGeo, roofMat);
                                roof.rotation.y = Math.PI / 4; roof.position.y = size * 1.2;
                                roof.castShadow = roof.receiveShadow = true; itemGroup.add(roof);

                                // Door
                                const doorGeo = new THREE.BoxGeometry(size * 0.3, size * 0.6, 0.05);
                                const doorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6, transparent: true, opacity: 0 });
                                const door = new THREE.Mesh(doorGeo, doorMat);
                                door.position.set(0, -size * 0.3, size * 0.75); itemGroup.add(door);

                                // Window
                                const windowGeo = new THREE.PlaneGeometry(size * 0.4, size * 0.4);
                                const windowMat = new THREE.MeshStandardMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.8 });
                                const window = new THREE.Mesh(windowGeo, windowMat);
                                window.position.set(size * 0.4, size * 0.2, size * 0.75); itemGroup.add(window);

                                // Chimney (optional)
                                if (Math.random() > 0.5) {
                                    const chimneyGeo = new THREE.BoxGeometry(size * 0.2, size * 0.5, size * 0.2);
                                    const chimneyMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.7, transparent: true, opacity: 0 });
                                    const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                                    chimney.position.set(size * 0.6, size * 1.4, size * 0.5);
                                    chimney.castShadow = chimney.receiveShadow = true; itemGroup.add(chimney);
                                }

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 1.5;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.75, size * 0.75, size * 0.75));
                                break;

                            case 'Mailbox': // Tiny/Small (effective size 0.45m - 1.65m)
                                size = Math.random() * 0.8 + 0.3;
                                itemGroup = new THREE.Group();

                                // Post
                                const postGeo = new THREE.CylinderGeometry(size * 0.1, size * 0.1, size * 1.5, 8);
                                const postMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                const post = new THREE.Mesh(postGeo, postMat);
                                post.position.y = size * 0.75; itemGroup.add(post);

                                // Box
                                const boxGeo = new THREE.BoxGeometry(size * 0.8, size * 0.5, size * 0.5);
                                const boxMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, roughness: 0.6, transparent: true, opacity: 0 });
                                const box = new THREE.Mesh(boxGeo, boxMat);
                                box.position.y = size * 1.5; itemGroup.add(box);

                                // Flag
                                const flagGeo = new THREE.BoxGeometry(size * 0.05, size * 0.3, size * 0.1);
                                const flagMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.6, transparent: true, opacity: 0 });
                                const flag = new THREE.Mesh(flagGeo, flagMat);
                                flag.position.set(size * 0.4, size * 1.6, 0); itemGroup.add(flag);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 1.5;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.4, size * 0.75, size * 0.25));
                                break;

                            case 'Fire Hydrant': // Tiny/Small (effective size 0.45m - 1.5m)
                                size = Math.random() * 0.7 + 0.3;
                                itemGroup = new THREE.Group();

                                const baseGeo = new THREE.CylinderGeometry(size * 0.4, size * 0.5, size * 0.3, 16);
                                const baseMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.6, transparent: true, opacity: 0 });
                                const base = new THREE.Mesh(baseGeo, baseMat);
                                base.position.y = size * 0.15; itemGroup.add(base);

                                const middleGeo = new THREE.CylinderGeometry(size * 0.3, size * 0.3, size * 0.8, 16);
                                const middleMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.6, transparent: true, opacity: 0 });
                                const middle = new THREE.Mesh(middleGeo, middleMat);
                                middle.position.y = size * 0.3 + size * 0.4; itemGroup.add(middle);

                                const topGeo = new THREE.CylinderGeometry(size * 0.2, size * 0.2, size * 0.2, 16);
                                const topMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.6, transparent: true, opacity: 0 });
                                const top = new THREE.Mesh(topGeo, topMat);
                                top.position.y = size * 0.3 + size * 0.8 + size * 0.1; itemGroup.add(top);

                                const nozzleGeo = new THREE.CylinderGeometry(size * 0.1, size * 0.1, size * 0.3, 8);
                                const nozzleMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.6, transparent: true, opacity: 0 });
                                const nozzle1 = new THREE.Mesh(nozzleGeo, nozzleMat);
                                nozzle1.rotation.z = Math.PI / 2; nozzle1.position.set(size * 0.3, size * 0.6, 0); itemGroup.add(nozzle1);
                                const nozzle2 = new THREE.Mesh(nozzleGeo, nozzleMat);
                                nozzle2.rotation.z = Math.PI / 2; nozzle2.position.set(-size * 0.3, size * 0.6, 0); itemGroup.add(nozzle2);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 1.5;
                                cannonShape = new CANNON.Cylinder(size * 0.5, size * 0.5, size * 1.5, 16);
                                break;

                            case 'Hot Dog Stand': // Small/Medium (effective size 1.6m - 4.6m)
                                size = Math.random() * 1.5 + 0.8;
                                itemGroup = new THREE.Group();

                                // Base cart
                                const cartBodyGeo = new THREE.BoxGeometry(size * 1.5, size * 0.8, size * 0.8);
                                const cartBodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, transparent: true, opacity: 0 });
                                const cartBody = new THREE.Mesh(cartBodyGeo, cartBodyMat);
                                cartBody.position.y = size * 0.4; itemGroup.add(cartBody);

                                // Roof
                                const roofStandGeo = new THREE.BoxGeometry(size * 1.8, size * 0.2, size * 1);
                                const roofStandMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6, transparent: true, opacity: 0 });
                                const roofStand = new THREE.Mesh(roofStandGeo, roofStandMat);
                                roofStand.position.y = size * 1.1; itemGroup.add(roofStand);

                                // Awning
                                const awningGeo = new THREE.BoxGeometry(size * 1.8, size * 0.1, size * 0.3);
                                const awningMat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, roughness: 0.6, transparent: true, opacity: 0 });
                                const awning = new THREE.Mesh(awningGeo, awningMat);
                                awning.position.set(0, size * 1.2, size * 0.5); itemGroup.add(awning);

                                // Wheels
                                const standWheelGeo = new THREE.CylinderGeometry(size * 0.15, size * 0.15, size * 0.1, 16);
                                const standWheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, transparent: true, opacity: 0 });
                                const standWheel1 = new THREE.Mesh(standWheelGeo, standWheelMat);
                                standWheel1.rotation.z = Math.PI / 2; standWheel1.position.set(size * 0.6, size * 0.1, size * 0.3); itemGroup.add(standWheel1);
                                const standWheel2 = new THREE.Mesh(standWheelGeo, standWheelMat);
                                standWheel2.rotation.z = Math.PI / 2; standWheel2.position.set(-size * 0.6, size * 0.1, size * 0.3); itemGroup.add(standWheel2);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 2;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.75, size * 0.5, size * 0.4));
                                break;

                            case 'Newspaper Stand': // Small (effective size 0.8m - 2.4m)
                                size = Math.random() * 0.8 + 0.4;
                                itemGroup = new THREE.Group();

                                // Base box
                                const nsBaseGeo = new THREE.BoxGeometry(size * 0.8, size * 1.2, size * 0.6);
                                const nsBaseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                const nsBase = new THREE.Mesh(nsBaseGeo, nsBaseMat);
                                nsBase.position.y = size * 0.6; itemGroup.add(nsBase);

                                // Top display
                                const nsTopGeo = new THREE.BoxGeometry(size * 0.9, size * 0.3, 0.05);
                                const nsTopMat = new THREE.MeshStandardMaterial({ color: 0xADD8E6, roughness: 0.5, transparent: true, opacity: 0 });
                                const nsTop = new THREE.Mesh(nsTopGeo, nsTopMat);
                                nsTop.position.set(0, size * 1.35, size * 0.3); itemGroup.add(nsTop);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 2;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.45, size * 0.75, size * 0.3));
                                break;

                            case 'Bicycle': // Medium (effective size 1.5m - 4.5m)
                                size = Math.random() * 1.5 + 0.75;
                                itemGroup = new THREE.Group();

                                // Frame
                                const frameMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6, transparent: true, opacity: 0 });
                                const frameGeo1 = new THREE.CylinderGeometry(0.05 * size, 0.05 * size, 1.2 * size, 8);
                                const frame1 = new THREE.Mesh(frameGeo1, frameMat);
                                frame1.rotation.z = Math.PI / 4;
                                frame1.position.set(0, 0.7 * size, 0);
                                itemGroup.add(frame1);

                                const frameGeo2 = new THREE.CylinderGeometry(0.05 * size, 0.05 * size, 0.8 * size, 8);
                                const frame2 = new THREE.Mesh(frameGeo2, frameMat);
                                frame2.rotation.z = -Math.PI / 4;
                                frame2.position.set(0.4 * size, 0.3 * size, 0);
                                itemGroup.add(frame2);

                                // Wheels
                                const wheelMatBike = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, transparent: true, opacity: 0 });
                                const wheelGeoBike = new THREE.TorusGeometry(0.4 * size, 0.05 * size, 16, 32);
                                const wheel1 = new THREE.Mesh(wheelGeoBike, wheelMatBike);
                                wheel1.position.set(0.6 * size, 0.4 * size, 0);
                                itemGroup.add(wheel1);
                                const wheel2 = new THREE.Mesh(wheelGeoBike, wheelMatBike);
                                wheel2.position.set(-0.6 * size, 0.4 * size, 0);
                                itemGroup.add(wheel2);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 3;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.8, size * 0.5, size * 0.2));
                                break;

                            case 'Skateboard': // Tiny (effective size 0.3m - 0.9m)
                                size = Math.random() * 0.3 + 0.15;
                                itemGroup = new THREE.Group();

                                // Board
                                const boardGeo = new THREE.BoxGeometry(size * 2, size * 0.05, size * 0.5);
                                const boardMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50, roughness: 0.6, transparent: true, opacity: 0 });
                                const board = new THREE.Mesh(boardGeo, boardMat);
                                board.position.y = size * 0.1; itemGroup.add(board);

                                // Wheels
                                const skWheelGeo = new THREE.CylinderGeometry(size * 0.1, size * 0.1, size * 0.15, 8);
                                const skWheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, transparent: true, opacity: 0 });
                                const skWheel1 = new THREE.Mesh(skWheelGeo, skWheelMat);
                                skWheel1.rotation.x = Math.PI / 2; skWheel1.position.set(size * 0.7, 0, size * 0.2); itemGroup.add(skWheel1);
                                const skWheel2 = new THREE.Mesh(skWheelGeo, skWheelMat);
                                skWheel2.rotation.x = Math.PI / 2; skWheel2.position.set(-size * 0.7, 0, size * 0.2); itemGroup.add(skWheel2);
                                const skWheel3 = new THREE.Mesh(skWheelGeo, skWheelMat);
                                skWheel3.rotation.x = Math.PI / 2; skWheel3.position.set(size * 0.7, 0, -size * 0.2); itemGroup.add(skWheel3);
                                const skWheel4 = new THREE.Mesh(skWheelGeo, skWheelMat);
                                skWheel4.rotation.x = Math.PI / 2; skWheel4.position.set(-size * 0.7, 0, -size * 0.2); itemGroup.add(skWheel4);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 1.5;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size, size * 0.1, size * 0.25));
                                break;

                            case 'Shopping Cart': // Medium (effective size 1.2m - 3.6m)
                                size = Math.random() * 1.2 + 0.6;
                                itemGroup = new THREE.Group();

                                // Basket
                                const basketGeo = new THREE.BoxGeometry(size * 1.2, size * 0.8, size * 0.8);
                                const basketMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.5, transparent: true, opacity: 0 });
                                const basket = new THREE.Mesh(basketGeo, basketMat);
                                basket.position.y = size * 0.4; itemGroup.add(basket);

                                // Handle
                                const handleGeo = new THREE.CylinderGeometry(size * 0.05, size * 0.05, size * 1.2, 8);
                                const handleMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.7, transparent: true, opacity: 0 });
                                const handle = new THREE.Mesh(handleGeo, handleMat);
                                handle.rotation.x = Math.PI / 2;
                                handle.position.set(0, size * 0.8, size * 0.5); itemGroup.add(handle);

                                // Wheels
                                const scWheelGeo = new THREE.CylinderGeometry(size * 0.15, size * 0.15, size * 0.1, 8);
                                const scWheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8, transparent: true, opacity: 0 });
                                const scWheel1 = new THREE.Mesh(scWheelGeo, scWheelMat);
                                scWheel1.rotation.x = Math.PI / 2; scWheel1.position.set(size * 0.5, 0, size * 0.3); itemGroup.add(scWheel1);
                                const scWheel2 = new THREE.Mesh(scWheelGeo, scWheelMat);
                                scWheel2.rotation.x = Math.PI / 2; scWheel2.position.set(-size * 0.5, 0, size * 0.3); itemGroup.add(scWheel2);
                                const scWheel3 = new THREE.Mesh(scWheelGeo, scWheelMat);
                                scWheel3.rotation.x = Math.PI / 2; scWheel3.position.set(size * 0.5, 0, -size * 0.3); itemGroup.add(scWheel3);
                                const scWheel4 = new THREE.Mesh(scWheelGeo, scWheelMat);
                                scWheel4.rotation.x = Math.PI / 2; scWheel4.position.set(-size * 0.5, 0, -size * 0.3); itemGroup.add(scWheel4);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 2.5;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.6, size * 0.4, size * 0.4));
                                break;

                            case 'Picnic Table': // Medium (effective size 1.5m - 4.5m)
                                size = Math.random() * 1.5 + 0.75;
                                itemGroup = new THREE.Group();

                                // Table top
                                const tableTopGeo = new THREE.BoxGeometry(size * 2, size * 0.1, size * 0.8);
                                const tableTopMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                const tableTop = new THREE.Mesh(tableTopGeo, tableTopMat);
                                tableTop.position.y = size * 0.7; itemGroup.add(tableTop);

                                // Benches
                                const benchGeo = new THREE.BoxGeometry(size * 2, size * 0.1, size * 0.3);
                                const benchMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                const bench1 = new THREE.Mesh(benchGeo, benchMat);
                                bench1.position.set(0, size * 0.4, size * 0.4); itemGroup.add(bench1);
                                const bench2 = new THREE.Mesh(benchGeo, benchMat);
                                bench2.position.set(0, size * 0.4, -size * 0.4); itemGroup.add(bench2);

                                // Legs
                                const legGeo = new THREE.BoxGeometry(size * 0.1, size * 0.6, size * 0.1);
                                const legMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, transparent: true, opacity: 0 });
                                const leg1 = new THREE.Mesh(legGeo, legMat);
                                leg1.position.set(size * 0.8, size * 0.3, size * 0.3); itemGroup.add(leg1);
                                const leg2 = new THREE.Mesh(legGeo, legMat);
                                leg2.position.set(-size * 0.8, size * 0.3, size * 0.3); itemGroup.add(leg2);
                                const leg3 = new THREE.Mesh(legGeo, legMat);
                                leg3.position.set(size * 0.8, size * 0.3, -size * 0.3); itemGroup.add(leg3);
                                const leg4 = new THREE.Mesh(legGeo, legMat);
                                leg4.position.set(-size * 0.8, size * 0.3, -size * 0.3); itemGroup.add(leg4);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 3;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size, size * 0.4, size * 0.4));
                                break;

                            case 'Alien Artifact': // Small/Medium (effective size 1m - 3m)
                                size = Math.random() * 1 + 0.5;
                                itemGroup = new THREE.Group();

                                // Main body (octahedron)
                                const artifactGeo = new THREE.OctahedronGeometry(size, 0);
                                const artifactMat = new THREE.MeshStandardMaterial({ color: 0x8A2BE2, roughness: 0.5, metalness: 0.8, transparent: true, opacity: 0 });
                                const artifact = new THREE.Mesh(artifactGeo, artifactMat);
                                itemGroup.add(artifact);

                                // Glowing core
                                const coreGeo = new THREE.SphereGeometry(size * 0.3, 16, 16);
                                const coreMat = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.8 });
                                const core = new THREE.Mesh(coreGeo, coreMat);
                                itemGroup.add(core);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 2;
                                cannonShape = new CANNON.Sphere(size);
                                break;

                            case 'Space Probe': // Medium (effective size 1.5m - 4.5m)
                                size = Math.random() * 1.5 + 0.75;
                                itemGroup = new THREE.Group();

                                // Main body (cylinder)
                                const probeBodyGeo = new THREE.CylinderGeometry(size * 0.3, size * 0.3, size * 1.5, 16);
                                const probeBodyMat = new THREE.MeshStandardMaterial({ color: 0x708090, roughness: 0.6, transparent: true, opacity: 0 });
                                const probeBody = new THREE.Mesh(probeBodyGeo, probeBodyMat);
                                itemGroup.add(probeBody);

                                // Solar panels
                                const probePanelGeo = new THREE.BoxGeometry(size * 1.5, 0.05, size * 0.6);
                                const probePanelMat = new THREE.MeshStandardMaterial({ color: 0x00008B, roughness: 0.2, metalness: 0.8, transparent: true, opacity: 0 });
                                const probePanel1 = new THREE.Mesh(probePanelGeo, probePanelMat);
                                probePanel1.position.x = size * 0.9; probePanel1.rotation.z = Math.PI / 2; itemGroup.add(probePanel1);
                                const probePanel2 = new THREE.Mesh(probePanelGeo, probePanelMat);
                                probePanel2.position.x = -size * 0.9; probePanel2.rotation.z = Math.PI / 2; itemGroup.add(probePanel2);

                                // Antenna
                                const antennaGeo = new THREE.CylinderGeometry(size * 0.02, size * 0.02, size * 0.8, 8);
                                const antennaMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7, transparent: true, opacity: 0 });
                                const antenna = new THREE.Mesh(antennaGeo, antennaMat);
                                antenna.position.y = size * 1.0; itemGroup.add(antenna);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 3;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 0.75, size * 0.75, size * 0.3));
                                break;
                            
                            case 'Satellite': // Small/Medium (effective size 1.25m - 5m)
                                size = Math.random() * 1.5 + 0.5;
                                itemGroup = new THREE.Group();

                                const mainSatBodyGeo = new THREE.BoxGeometry(size * 0.5, size * 0.5, size * 1.5);
                                const mainSatBodyMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5, transparent: true, opacity: 0 });
                                const mainSatBody = new THREE.Mesh(mainSatBodyGeo, mainSatBodyMat);
                                itemGroup.add(mainSatBody);

                                const solarPanelGeo = new THREE.BoxGeometry(size * 2, 0.05, size * 0.8);
                                const solarPanelMat = new THREE.MeshStandardMaterial({ color: 0x00008B, roughness: 0.2, metalness: 0.8, transparent: true, opacity: 0 });
                                const panel1 = new THREE.Mesh(solarPanelGeo, solarPanelMat);
                                panel1.position.x = size * 1.25; itemGroup.add(panel1);
                                const panel2 = new THREE.Mesh(solarPanelGeo, solarPanelMat);
                                panel2.position.x = -size * 1.25; itemGroup.add(panel2);

                                threeMesh = itemGroup;
                                threeMesh.userData.size = size * 2.5; // Larger effective size
                                cannonShape = new CANNON.Box(new CANNON.Vec3(size * 1.25, size * 0.25, size * 0.75));
                                break;

                            default: // Fallback, should not be hit if itemNames are well-defined
                                console.warn(`Unknown item name '${itemName}' encountered. Using generic cube.`);
                                threeMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: color, roughness: 0.6, transparent: true, opacity: 0 }));
                                threeMesh.userData.size = 1;
                                cannonShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                                break;
                        }

                        // For non-instanced items, ensure cast/receive shadow is set
                        if (!threeMesh.userData.isInstanced) {
                            threeMesh.castShadow = true;
                            threeMesh.receiveShadow = true;
                            threeMesh.userData.cannonShape = cannonShape; // Store the Cannon.js shape
                        }
                    }

                    console.log(`After switch - threeMesh:`, threeMesh);
                    console.log(`After switch - cannonShape:`, cannonShape);

                    // Defensive check: Ensure threeMesh and its userData.size are defined after the switch
                    if (!threeMesh || threeMesh.userData === undefined || threeMesh.userData.size === undefined) {
                        console.error(`Skipping item due to missing essential properties after switch for item: ${itemName}`);
                        continue; 
                    }
                    
                    // --- Procedural Generation Position Logic (Outside Frustum) ---
                    const maxAttempts = 50;
                    let positionFound = false;
                    let currentX, currentZ;
                    let attempts = 0;

                    while (!positionFound && attempts < maxAttempts) {
                        currentX = centerPosition.x + (Math.random() - 0.5) * spawnRadius * 2;
                        currentZ = centerPosition.z + (Math.random() - 0.5) * spawnRadius * 2;

                        // Clamp positions to stay within map boundaries
                        currentX = THREE.MathUtils.clamp(currentX, -mapBoundary, mapBoundary);
                        currentZ = THREE.MathUtils.clamp(currentZ, -mapBoundary, mapBoundary);

                        const tempSphere = new THREE.Sphere(new THREE.Vector3(currentX, threeMesh.userData.size / 2, currentZ), threeMesh.userData.size / 2);

                        // Check if the temporary sphere intersects with the camera's frustum
                        if (!frustum.intersectsSphere(tempSphere)) {
                            positionFound = true;
                        }
                        attempts++;
                    }
                    // If after maxAttempts, a non-visible position wasn't found, use the last generated one.
                    // This prevents infinite loops but might occasionally place an item in view if no valid spot is found.

                    const yPos = threeMesh.userData.size / 2 + 0.1; // Place slightly above ground to prevent falling through
                    
                    if (isInstanced) {
                        // Set instance matrix for instanced meshes
                        dummy.position.set(currentX, yPos, currentZ);
                        dummy.scale.set(size, size, size); // Apply scale here
                        dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);
                        dummy.updateMatrix();
                        
                        const instancedMesh = instancedMeshes[instancedId];
                        const instanceIndex = instancedMesh.count; // Get current count as index
                        if (instanceIndex < MAX_INSTANCES) {
                            instancedMesh.setMatrixAt(instanceIndex, dummy.matrix);
                            instancedMesh.setColorAt(instanceIndex, new THREE.Color(color)); // Set color per instance
                            instancedMesh.instanceMatrix.needsUpdate = true;
                            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;

                            threeMesh.position.set(currentX, yPos, currentZ); // Store for physics
                            threeMesh.rotation.set(0, Math.random() * Math.PI * 2, 0);
                            threeMesh.userData.instanceIndex = instanceIndex; // Store index for later removal
                            instancedMesh.count++; // Increment instance count
                        } else {
                            console.warn(`Max instances reached for ${itemName}. Skipping.`);
                            continue; // Skip if max instances reached
                        }
                    } else {
                        threeMesh.position.set(currentX, yPos, currentZ);
                        threeMesh.rotation.set(0, Math.random() * Math.PI * 2, 0);
                        scene.add(threeMesh);
                    }

                    itemsToCollect.push(threeMesh);

                    // Add fade-in properties
                    threeMesh.userData.fadeStartTime = Date.now();
                    threeMesh.userData.isFadingIn = true;


                    // Create Cannon.js body for the item
                    const itemBody = new CANNON.Body({ mass: threeMesh.userData.size * 5, shape: cannonShape });
                    itemBody.position.set(currentX, yPos, currentZ); // Use the final position
                    itemBody.quaternion.copy(threeMesh.quaternion);
                    itemBody.userData = { threeMesh: threeMesh }; // Fix: Changed itemThreeMesh to threeMesh
                    world.addBody(itemBody); // Use world.addBody for cannon-es
                    physicsBodies.push(itemBody);
                }
                console.log(`createCollectibleItems: Finished creating ${count} items.`);
            }

            function createPowerUpItems(count) {
                console.log(`Creating ${count} power-up items.`);
                const powerUpColors = {
                    magnetism: 0xFFD700, // Gold
                    speedBoost: 0x00BFFF, // Deep Sky Blue
                    stickyCoating: 0x32CD32, // Lime Green
                    vacuumBoost: 0x8A2BE2, // Blue Violet
                };
                const powerUpGeometries = {
                    magnetism: new THREE.TorusGeometry(0.8, 0.3, 16, 100),
                    speedBoost: new THREE.ConeGeometry(0.8, 1.5, 32),
                    stickyCoating: new THREE.DodecahedronGeometry(1),
                    vacuumBoost: new THREE.OctahedronGeometry(1) // Added geometry for vacuumBoost
                };

                for (let i = 0; i < count; i++) {
                    const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    const material = new THREE.MeshStandardMaterial({
                        color: powerUpColors[type],
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: powerUpColors[type],
                        emissiveIntensity: 0.5,
                    });
                    const powerUpMesh = new THREE.Mesh(powerUpGeometries[type], material);
                    powerUpMesh.userData.type = type;
                    powerUpMesh.userData.isPowerUp = true;

                    const x = (Math.random() - 0.5) * mapBoundary * 1.5;
                    const z = (Math.random() - 0.5) * mapBoundary * 1.5;
                    powerUpMesh.position.set(x, 2, z);
                    scene.add(powerUpMesh);
                    powerUpItems.push(powerUpMesh);
                }
            }

            function createSuckingEffect() {
                const geometry = new THREE.ConeGeometry(5, 10, 32, 1, true);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });
                const suckingEffect = new THREE.Mesh(geometry, material);
                suckingEffect.rotation.x = Math.PI / 2;
                suckingEffect.visible = false;
                katamari.add(suckingEffect);
                return suckingEffect;
            }

            
            let screenShake = { intensity: 0, duration: 0, startTime: 0 };

            function shakeScreen(intensity) {
                screenShake.intensity = intensity;
                screenShake.duration = 200; // ms
                screenShake.startTime = Date.now();
            }

            function resetKatamariPosition() {
                console.log("Resetting Katamari position...");
                if (katamariBody) {
                    katamariBody.position.set(0, katamariRadius, 0);
                    katamariBody.velocity.set(0,0,0);
                    katamariBody.angularVelocity.set(0,0,0);
                    katamari.position.copy(katamariBody.position);
                    katamari.quaternion.copy(katamariBody.quaternion);
                    lastGenerationPosition.copy(katamari.position); // Reset generation position on reset
                    console.log("Katamari position reset to (0,0,0).");
                } else {
                    console.warn("resetKatamariPosition: katamariBody is not defined.");
                }
            }

            function onWindowResize() {
                console.log("Window resized. Updating camera and renderer size.");
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                // Gradually increase suck factor as the ball gets larger, never going over 3
                const minSuckRangeFactor = 1.5; // Starting suck factor for small Katamari
                const maxSuckRangeFactor = 3.0; // Maximum suck factor
                const suckFactorGrowthRate = 0.1; // How quickly suck factor increases with radius

                let calculatedSuckRangeFactor = minSuckRangeFactor + (katamariRadius * suckFactorGrowthRate);
                calculatedSuckRangeFactor = Math.min(maxSuckRangeFactor, calculatedSuckRangeFactor); // Cap at max

                currentSuckRange = updatePowerUps(calculatedSuckRangeFactor); // Update suck range based on power-ups
                fpsCounter.update();
                requestAnimationFrame(animate);

                if (isGeneratingLevel || !katamari || !world) {
                    // console.log("Animation paused: Generating level or core objects not ready."); // Too chatty
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                    return;
                }

                const deltaTime = clock.getDelta();
                
                // Reintroduce currentVelocityLength for sound and camera FOV
                const currentVelocityLength = katamariBody.velocity.length();

                // Update frustum for visibility checks
                camera.updateMatrixWorld(); // Ensure camera's world matrix is up-to-date
                frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

                // Manage physics body sleeping/waking based on distance and frustum visibility
                for (const body of physicsBodies) {
                    if (body.userData && body.userData.threeMesh) {
                        const itemThreeMesh = body.userData.threeMesh; 
                        const distanceToKatamari = katamari.position.distanceTo(itemThreeMesh.position);
                        
                        // Create a temporary sphere for frustum check based on item's size and position
                        const itemBoundingSphere = new THREE.Sphere(itemThreeMesh.position, itemThreeMesh.userData.size / 2);
                        const isInFrustum = frustum.intersectsSphere(itemBoundingSphere);

                        if (distanceToKatamari < physicsActiveDistance || isInFrustum) {
                            // If close to Katamari or in view, ensure physics body is awake
                            if (body.sleepState === CANNON.Body.SLEEPING) {
                                body.wakeUp();
                            }
                        } else {
                            // If far and not in view, put physics body to sleep
                            if (body.sleepState === CANNON.Body.AWAKE) {
                                body.sleep();
                            }
                        }
                    }
                }

                // Apply attraction forces to items
                const katamariMass = katamariBody.mass;
                
                const fullPhysicsRange = 50;
                const simplifiedPhysicsRange = 100;
                const itemsToRemove = [];

                for (const body of physicsBodies) {
                    if (body.userData && body.userData.threeMesh && body.userData.threeMesh.userData.isAttracting) {
                        const itemThreeMesh = body.userData.threeMesh;
                        const distance = katamari.position.distanceTo(itemThreeMesh.position);
                        const suckRange = katamariRadius * currentSuckRange; // Use the globally updated suckRange

                        if (distance < suckRange) {
                            // Gravitational pull (inverse square law)
                            // Simplified attraction force: proportional to Katamari radius, inversely proportional to distance
                            // This is more stable than using rapidly increasing mass
                            let forceMagnitude = (katamariRadius * 50) / distance; // Adjust 50 for desired strength

                            // Clamp force to prevent extreme values when very close or too strong
                            forceMagnitude = Math.min(forceMagnitude, 50); // Max force to prevent instability

                            // Smoothly reduce force as item gets very close to attachment point
                            const attachmentThreshold = katamariRadius + itemThreeMesh.userData.size;
                            const fadeDistance = 0.5; // Start fading force when item is within 0.5 units of attachmentThreshold
                            if (distance < attachmentThreshold + fadeDistance) {
                                const fadeProgress = 1 - ((distance - attachmentThreshold) / fadeDistance);
                                forceMagnitude *= Math.max(0, fadeProgress); // Reduce force to 0 as it reaches attachmentThreshold
                            }

                            const direction = new CANNON.Vec3();
                            katamariBody.position.vsub(body.position, direction);
                            direction.normalize();

                            const attractionForce = new CANNON.Vec3();
                            direction.scale(forceMagnitude, attractionForce);
                            body.applyForce(attractionForce, body.position);

                            // Apply torque for orbital motion (simplified)
                            const torqueMagnitude = forceMagnitude * 0.01; // Adjust for desired orbital speed
                            const torqueAxis = new CANNON.Vec3(0, 1, 0); // Rotate around Y-axis
                            const attractionTorque = new CANNON.Vec3();
                            torqueAxis.scale(torqueMagnitude, attractionTorque);
                            body.applyTorque(attractionTorque);

                            // Apply angular damping to orbiting items
                            body.angularVelocity.scale(0.95, body.angularVelocity); // Apply 5% damping per frame

                            // If close enough, attach immediately
                            if (distance < katamariRadius + itemThreeMesh.userData.size) {
                                attachItem(itemThreeMesh, body); // This is where the item is "collected"
                                itemThreeMesh.userData.isAttracting = false; // Stop attracting
                                itemsToRemove.push(body);
                                // console.log(`Item ${itemThreeMesh.userData.size.toFixed(2)}m merged with Katamari.`); // Removed console.log
                            }

                        } else {
                            // If item leaves suck range, stop attracting
                            itemThreeMesh.userData.isAttracting = false;

                        }
                    }
                }

                for (const body of itemsToRemove) {
                    const index = physicsBodies.indexOf(body);
                    if (index > -1) {
                        physicsBodies.splice(index, 1);
                    }
                }

                

                // Update attraction hum sound
                let totalAttractionForce = 0;
                let attractedItemsCount = 0;
                for (const body of physicsBodies) {
                    if (body.userData && body.userData.threeMesh && body.userData.threeMesh.userData.isAttracting) {
                        const itemThreeMesh = body.userData.threeMesh;
                        const distance = katamari.position.distanceTo(itemThreeMesh.position);
                        if (distance < currentSuckRange) { // Use the globally updated suckRange
                            totalAttractionForce += body.userData.attractionForce.length();
                            attractedItemsCount++;
                        }
                    }
                }

                if (attractedItemsCount > 0) {
                    const avgForce = totalAttractionForce / attractedItemsCount;
                    const normalizedForce = Math.min(1, avgForce / 100); // Normalize force to 0-1 range
                    const targetFrequency = THREE.MathUtils.lerp(50, 200, normalizedForce); // Pitch up to 200Hz
                    const targetVolume = THREE.MathUtils.lerp(-40, -10, normalizedForce); // Increase volume

                    attractionHum.frequency.value = targetFrequency;
                    attractionHum.volume.value = targetVolume;
                } else {
                    attractionHum.volume.value = -40; // Quiet when no items are attracted
                }

                // Sync visual position BEFORE physics step
                katamari.position.copy(katamariBody.position);
                katamari.quaternion.copy(katamariBody.quaternion);
                
                // Update physics world
                try {
                    world.step(timeStep, deltaTime);
                } catch (e) {
                    console.error("Error during world.step:", e);
                    renderer.render(scene, camera);
                    return;
                }

                // NEW: Clamp angular velocity to prevent runaway spinning
                const maxAngularSpeed = 5; // Radians per second (adjust as needed)
                const currentAngularSpeed = katamariBody.angularVelocity.length();
                if (currentAngularSpeed > maxAngularSpeed) {
                    katamariBody.angularVelocity.scale(maxAngularSpeed / currentAngularSpeed, katamariBody.angularVelocity);
                }

                // NEW: Increase angular damping
                katamariBody.angularDamping = 0.99; // Increased from 0.95

                

                

                // Sync Three.js Katamari with physics body
                

                // Sync Three.js item meshes with their Cannon.js bodies
                const dummy = new THREE.Object3D(); // Re-use dummy object
                for (const body of physicsBodies) {
                    if (body.userData && body.userData.threeMesh) {
                        const itemThreeMesh = body.userData.threeMesh;
                        // Only update visual mesh if physics body is awake or has recently moved
                        if (body.sleepState === CANNON.Body.AWAKE || body.velocity.length() > 0.01 || body.angularVelocity.length() > 0.01) {
                            if (itemThreeMesh.userData.isInstanced) {
                                // Update the matrix for the specific instance
                                dummy.position.copy(body.position);
                                dummy.quaternion.copy(body.quaternion);
                                dummy.scale.set(itemThreeMesh.userData.size, itemThreeMesh.userData.size, itemThreeMesh.userData.size);
                                dummy.updateMatrix();
                                instancedMeshes[itemThreeMesh.userData.instancedId].setMatrixAt(itemThreeMesh.userData.instanceIndex, dummy.matrix);
                                instancedMeshes[itemThreeMesh.userData.instancedId].instanceMatrix.needsUpdate = true;
                            } else {
                                itemThreeMesh.position.copy(body.position);
                                itemThreeMesh.quaternion.copy(body.quaternion);
                            }
                        }
                    }
                }

                // Handle item fade-in (for newly created items)
                for (const item of itemsToCollect) {
                    if (item.userData.isFadingIn) {
                        const elapsed = Date.now() - item.userData.fadeStartTime;
                        const progress = Math.min(1, elapsed / itemFadeDuration);

                        if (item.userData.isInstanced) {
                            // For instanced meshes, update opacity via color attribute if supported, or material opacity
                            // For now, we'll just update the material opacity of the instanced mesh itself,
                            // which affects all instances. A more advanced solution would be custom shaders.
                            const instancedMat = instancedMaterials[item.userData.instancedId];
                            if (instancedMat && instancedMat.transparent) {
                                instancedMat.opacity = progress;
                            }
                        } else if (item.isGroup) { // If it's a group, iterate through its meshes
                            item.traverse(function (object) {
                                if (object.isMesh && object.material.transparent) {
                                    object.material.opacity = progress;
                                }
                            });
                        } else if (item.isMesh && item.material.transparent) { // If it's a single mesh
                            item.material.opacity = progress;
                        }

                        if (progress === 1) {
                            item.userData.isFadingIn = false;
                        }
                    }
                }

                // Handle attached item orbiting and compression
                for (let i = katamari.children.length - 1; i >= 0; i--) {
                    const child = katamari.children[i];
                    if (child.userData.isAttachedToKatamari && child.userData.initialLocalPosition) {
                        // Create a temporary vector from the initial local position
                        const currentLocalPosition = child.userData.initialLocalPosition.clone();

                        // Apply an additional rotation for orbiting effect
                        // This rotation should be cumulative over time
                        child.userData.currentOrbitalAngle = (child.userData.currentOrbitalAngle || 0) + child.userData.rotationSpeed * deltaTime;
                        currentLocalPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), child.userData.currentOrbitalAngle);

                        // Set the item's position to the calculated local position
                        child.position.copy(currentLocalPosition);

                        // Optional: Make items slowly rotate on their own axis
                        child.rotation.y += deltaTime * 0.5; 
                    }
                }

                // Update particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    particle.userData.age += deltaTime;

                    // Apply gravity and velocity
                    particle.userData.velocity.addScaledVector(particle.userData.gravity, deltaTime);
                    
                    // If target position is set, move towards it
                    if (particle.userData.targetPosition) {
                        const direction = new THREE.Vector3().subVectors(particle.userData.targetPosition, particle.position).normalize();
                        particle.userData.velocity.add(direction.multiplyScalar(5 * deltaTime)); // Adjust attraction speed
                    }

                    particle.position.addScaledVector(particle.userData.velocity, deltaTime);

                    // Fade out
                    const opacity = 1 - (particle.userData.age / particle.userData.lifespan);
                    if (particle.material.opacity !== opacity) { // Only update if changed
                        particle.material.opacity = opacity;
                    }
                    

                    if (particle.userData.age >= particle.userData.lifespan || particle.position.y < 0) {
                        scene.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        particles.splice(i, 1);
                    }
                }

                // Calculate movement direction relative to camera
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0;
                cameraDirection.normalize();

                const rightDirection = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), cameraDirection).normalize();

                let desiredMovementDirection = new CANNON.Vec3(0, 0, 0); // Use a Cannon.js vector for desired movement direction
                let isMovingInput = false; // Track if there's *any* directional input

                // --- Dynamic Acceleration Calculation ---
                const baseAcceleration = 60; // Base acceleration for small Katamari
                const maxAcceleration = 200; // Max acceleration for large Katamari
                const accelerationGrowthFactor = 0.1; // How quickly acceleration increases with radius

                let currentAcceleration = baseAcceleration + (katamariRadius * accelerationGrowthFactor);
                currentAcceleration = Math.min(currentAcceleration, maxAcceleration); // Cap the acceleration

                desiredMovementDirection = new CANNON.Vec3(0, 0, 0); // Use a Cannon.js vector for desired movement direction
                isMovingInput = false; // Track if there's *any* directional input

                if (useGyroscope) {
                    // Gyroscope input
                    // Use normalized gyro values
                    const forwardBackwardTilt = -gyro.normalizedGamma;
                    const leftRightTilt = -gyro.normalizedBeta;

                    // Apply movement based on tilt, scaled by gyroSensitivity
                    desiredMovementDirection.x += cameraDirection.x * forwardBackwardTilt * gyroSensitivity;
                    desiredMovementDirection.z += cameraDirection.z * forwardBackwardTilt * gyroSensitivity;
                    desiredMovementDirection.x -= rightDirection.x * leftRightTilt * gyroSensitivity;
                    desiredMovementDirection.z -= rightDirection.z * leftRightTilt * gyroSensitivity;
                    
                    // Consider input active if there's significant tilt
                    if (Math.abs(forwardBackwardTilt) > 0.05 || Math.abs(leftRightTilt) > 0.05) { // Reduced threshold for responsiveness
                        isMovingInput = true;
                    }
                } else {
                    // Determine desired movement direction based on keyboard input
                    let forward = 0;
                    let sideways = 0;

                    if (keys['w'] || keys['arrowup']) {
                        forward = -1;
                    }
                    if (keys['s'] || keys['arrowdown']) {
                        forward = 1;
                    }
                    if (keys['a'] || keys['arrowleft']) {
                        sideways = -1;
                    }
                    if (keys['d'] || keys['arrowright']) {
                        sideways = 1;
                    }

                    if (forward !== 0 || sideways !== 0) {
                        desiredMovementDirection.x = cameraDirection.x * forward + rightDirection.x * sideways;
                        desiredMovementDirection.z = cameraDirection.z * forward + rightDirection.z * sideways;
                        isMovingInput = true;
                    }

                    // Determine desired movement direction based on touch input
                    if (touchInput.active) {
                        const deltaX = touchInput.currentX - touchInput.startX;
                        const deltaY = touchInput.currentY - touchInput.startY;

                        const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        if (length > touchDeadZone) {
                            const normalizedDeltaX = deltaX / length;
                            const normalizedDeltaY = deltaY / length;

                            // Map touch X to right/left, touch Y to forward/backward relative to camera
                            desiredMovementDirection.x += (-cameraDirection.x * normalizedDeltaY + rightDirection.x * normalizedDeltaX) * touchSensitivity;
                            desiredMovementDirection.z += (-cameraDirection.z * normalizedDeltaY + rightDirection.z * normalizedDeltaX) * touchSensitivity;
                            isMovingInput = true;
                        }
                    }
                }

                // Normalize desiredMovementDirection if there's input
                if (isMovingInput) {
                    const initialMagnitude = desiredMovementDirection.length(); // Get magnitude before normalization
                    desiredMovementDirection.normalize();

                    // Calculate the torque to apply for rolling
                    // Torque = Force * Radius (simplified for a sphere rolling on a plane)
                    // We want to apply torque that causes rotation in the direction of movement
                    const torqueMagnitude = currentAcceleration * katamariBody.mass * katamariRadius * 0.5; // Adjust multiplier for desired responsiveness

                    // The axis of rotation should be perpendicular to the desired movement direction and the 'up' vector
                    const rotationAxis = new CANNON.Vec3();
                    const upVector = new CANNON.Vec3(0, 1, 0); // Y-axis is up
                    desiredMovementDirection.cross(upVector, rotationAxis); // Cross product gives perpendicular vector
                    rotationAxis.normalize();

                    const torque = new CANNON.Vec3();
                    rotationAxis.scale(torqueMagnitude, torque);

                    // Apply torque to the Katamari body
                    katamariBody.applyTorque(torque);

                    // Adjust damping when actively moving
                    katamariBody.linearDamping = 0.05;
                    katamariBody.angularDamping = 0.05;
                } else {
                    // Increase damping when no input to slow down
                    katamariBody.linearDamping = 0.9;
                    katamariBody.angularDamping = 0.9; // Adjusted to be consistent with linear damping
                }


                // --- Smooth Growth Animation ---
                if (katamariRadius < targetRadius) {
                    katamariRadius = THREE.MathUtils.lerp(katamariRadius, targetRadius, 0.05); // Adjust the interpolation factor for faster/slower growth
                    updateKatamariPhysics();
                    updateKatamariVisualsAndPhysics();
                }

                // Smooth out the speed for camera FOV (use actual physics velocity)
                smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, currentVelocityLength, 0.1);

                // Clamp Katamari position to stay within bounds (only X and Z)
                katamariBody.position.x = THREE.MathUtils.clamp(katamariBody.position.x, -mapBoundary + katamariRadius, mapBoundary - katamariRadius);
                katamariBody.position.z = THREE.MathUtils.clamp(katamariBody.position.z, -mapBoundary + katamariRadius, mapBoundary - katamariRadius);
                // Removed: katamariBody.position.y = katamariRadius; // Let physics handle Y position

                // Play rolling sound based on current velocity
                if (currentVelocityLength > 0.1) {
                    playRollingSound(currentVelocityLength);
                } else {
                    stopRollingSound();
                }

                // Also update the Three.js Katamari position to match the clamped physics body position
                katamari.position.copy(katamariBody.position);

                // --- Continuous Collision Detection ---
                const katamariVelocity = katamariBody.velocity;
                const predictedPosition = new THREE.Vector3().copy(katamari.position).add(katamariVelocity.clone().scale(deltaTime));

                for (const body of physicsBodies) {
                    if (body.userData && body.userData.threeMesh) {
                        const itemThreeMesh = body.userData.threeMesh;
                        const itemPosition = itemThreeMesh.position;

                        // Simple ray-sphere intersection test
                        const ray = new THREE.Ray(katamari.position, katamariVelocity.clone().normalize());
                        const sphere = new THREE.Sphere(itemPosition, itemThreeMesh.userData.size);

                        if (ray.intersectsSphere(sphere)) {
                            handleKatamariCollision({ body: body });
                        }
                    }
                }

                checkMountainCollisions(); // Check for collisions with mountains

                // Dynamic item generation based on travel distance
                if (katamari.position.distanceTo(lastGenerationPosition) > generationDistanceThreshold) {
                    console.log("Generating new items due to travel distance.");
                    createCollectibleItems(50, currentTheme.items, katamari.position, 150); // Generate 50 items around current position, in a 150 unit radius (reduced count)
                    lastGenerationPosition.copy(katamari.position); // Update last generation position
                }

                // Clean up old items that are too far away
                cleanupOldItems();

                // Check for power-up collection
                for (let i = powerUpItems.length - 1; i >= 0; i--) {
                    const powerUpMesh = powerUpItems[i];
                    const distance = katamari.position.distanceTo(powerUpMesh.position);
                    if (distance < katamariRadius + 1) { // 1 is the approximate radius of power-ups
                        handlePowerUpCollection(powerUpMesh);
                    }
                }

                updateCamera(smoothedSpeed); // Pass smoothedSpeed to updateCamera
                renderer.render(scene, camera); // Render the scene

                // Update UI elements
                katamariSizeUI.textContent = `${katamariRadius.toFixed(2)}m`;
                katamariSpeedUI.textContent = `${smoothedSpeed.toFixed(2)}m/s`;
                progressBar.style.width = `${Math.min(100, (katamariRadius / targetKatamariSize) * 100)}%`;

                // Check for win condition
                if (katamariRadius >= targetKatamariSize && messageOverlay.style.display === 'none') {
                    messageOverlay.textContent = `LEVEL ${currentLevel} COMPLETE! You've grown a magnificent Katamari! Click to continue.`;
                    messageOverlay.style.display = 'block';
                    stopRollingSound();
                    currentLevel++; // Advance level for next game
                    console.log(`Level ${currentLevel - 1} completed! New target size: ${targetKatamariSize.toFixed(2)}m`);
                }
            }
            
            // --- CLEANUP OLD ITEMS ---
            function cleanupOldItems() {
                // console.log("Cleaning up old items..."); // Too chatty
                // Clean up collectible items
                for (let i = itemsToCollect.length - 1; i >= 0; i--) {
                    const itemThreeMesh = itemsToCollect[i];
                    // Only remove if not already marked for removal (i.e., not collected)
                    if (katamari.position.distanceTo(itemThreeMesh.position) > cleanupDistanceThreshold) {
                        const itemCannonBody = physicsBodies.find(body => body.userData?.threeMesh === itemThreeMesh);
                        if (itemCannonBody) {
                            world.removeBody(itemCannonBody); // Use world.removeBody for cannon-es
                            physicsBodies = physicsBodies.filter(b => b !== itemCannonBody);
                        }
                        if (itemThreeMesh.userData.isInstanced) {
                            // For instanced meshes, hide the instance by setting its scale to zero
                            const instancedMesh = instancedMeshes[itemThreeMesh.userData.instancedId];
                            if (instancedMesh && itemThreeMesh.userData.instanceIndex !== -1) {
                                const dummy = new THREE.Object3D();
                                dummy.position.copy(itemThreeMesh.position);
                                dummy.quaternion.copy(itemThreeMesh.quaternion);
                                dummy.scale.set(0, 0, 0); // Hide the instance
                                dummy.updateMatrix();
                                instancedMesh.setMatrixAt(itemThreeMesh.userData.instanceIndex, dummy.matrix);
                                instancedMesh.instanceMatrix.needsUpdate = true;
                                // Optionally, decrement count if you want to reuse indices, but for simplicity, we just hide
                            }
                        } else {
                            scene.remove(itemThreeMesh);
                        }
                        itemsToCollect.splice(i, 1); // Remove from itemsToCollect immediately
                        // console.log("Removed item due to distance."); // Too chatty
                    }
                }
            }

            // --- COLLISION DETECTION (Physics-based for Katamari-Item) ---
            function handleKatamariCollision(event) {
                const otherBody = event.body;

                // Ignore collisions with non-item bodies (like the ground)
                if (!otherBody.userData || !otherBody.userData.threeMesh) {
                    return;
                }
                console.log("Collision detected with:", otherBody.userData.threeMesh.userData);

                const itemThreeMesh = otherBody.userData.threeMesh;
                const itemCannonBody = otherBody;

                // Ensure it's a collectible item that hasn't been picked up yet
                if (!itemsToCollect.includes(itemThreeMesh)) {
                    return;
                }

                // Check if Katamari is large enough to collect the item (now allows larger items)
                if (katamariRadius >= itemThreeMesh.userData.size * 0.5) { // Katamari can pick up items up to 1.5 times its size
                    // Check if the item is already being attracted
                    if (!itemThreeMesh.userData.isAttracting) {
                        itemThreeMesh.userData.isAttracting = true;
                        itemThreeMesh.userData.attractionStartTime = Date.now();
                        itemCannonBody.userData.attractionForce = new CANNON.Vec3(); // Store attraction force
                        itemCannonBody.userData.attractionTorque = new CANNON.Vec3(); // Store attraction torque
                        itemThreeMesh.userData.attachmentStage = 0; // 0: orbiting, 1: locking, 2: merging
                        console.log(`Initiating attraction for item: ${itemThreeMesh.userData.size.toFixed(2)}m`);
                        
                        let itemColor;
                        if (itemThreeMesh.userData.isInstanced) {
                            itemColor = itemThreeMesh.userData.color; // Use stored color for instanced mesh
                        } else if (itemThreeMesh.isGroup) {
                            itemColor = itemThreeMesh.children[0].material.color;
                        } else {
                            itemColor = itemThreeMesh.material.color;
                        }
                        createParticles(itemThreeMesh.position, itemColor, 'suck', itemThreeMesh.userData.size, katamari.position);
                    }
                } else {
                    // Katamari is smaller than the item, so it should bounce off
                    const pushDirection = new THREE.Vector3().subVectors(katamari.position, itemThreeMesh.position).normalize();
                    const pushForce = pushDirection.multiplyScalar(2); // Stronger pushback force

                    // Apply an impulse to the physics body for a more immediate effect
                    const impulse = new CANNON.Vec3(pushForce.x, pushForce.y, pushForce.z).scale(10);
                    katamariBody.applyImpulse(impulse, new CANNON.Vec3(0,0,0));

                    shakeScreen(0.1); // Gentle shake for collision
                }
            }

            function handlePowerUpCollection(powerUpMesh) {
                const type = powerUpMesh.userData.type;
                console.log(`Collected power-up: ${type}`);

                // Activate the power-up
                activePowerUps[type] = Date.now() + powerUpDuration;

                // Remove the power-up from the scene and the array
                scene.remove(powerUpMesh);
                powerUpItems = powerUpItems.filter(item => item !== powerUpMesh);

                // Play a sound for power-up collection
                collectionSynth.triggerAttackRelease("C5", "8n");
            }

            function updatePowerUps(initialSuckRangeFactor) {
                const now = Date.now();
                let speedBoostActive = false;
                let magnetismActive = false;
                let vacuumBoostActive = false;
                let powerUpStatusHTML = '';

                let effectiveSuckRangeFactor = initialSuckRangeFactor; // Start with the calculated base suck range factor

                for (const type in activePowerUps) {
                    const expiryTime = activePowerUps[type];
                    if (now > expiryTime) {
                        delete activePowerUps[type];
                        console.log(`Power-up expired: ${type}`);
                        continue;
                    }

                    const remainingTime = ((expiryTime - now) / 1000).toFixed(1);
                    powerUpStatusHTML += `<div>${type}: ${remainingTime}s</div>`;

                    switch (type) {
                        case 'magnetism':
                            magnetismActive = true;
                            break;
                        case 'speedBoost':
                            speedBoostActive = true;
                            break;
                        case 'stickyCoating':
                            // This is handled in checkMountainCollisions
                            break;
                        case 'vacuumBoost':
                            vacuumBoostActive = true;
                            effectiveSuckRangeFactor *= 2; // Double the suck range factor
                            break;
                    }
                }

                document.getElementById('power-up-status').innerHTML = powerUpStatusHTML;

                // Apply speed boost
                if (speedBoostActive) {
                    
                } else {
                    
                }

                // Update sucking effect visual
                if (suckingEffect) {
                    if (magnetismActive) {
                        suckingEffect.visible = true;
                        // Scale based on the effectiveSuckRangeFactor to match visual with actual suck range
                        suckingEffect.scale.x = katamariRadius * 0.5 * (effectiveSuckRangeFactor / initialSuckRangeFactor); 
                        suckingEffect.scale.y = katamariRadius * 0.5 * (effectiveSuckRangeFactor / initialSuckRangeFactor);
                        suckingEffect.scale.z = katamariRadius * 0.5 * (effectiveSuckRangeFactor / initialSuckRangeFactor);
                        suckingEffect.material.opacity = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    } else {
                        suckingEffect.visible = false;
                    }
                }
                // Return the calculated effective suck range factor
                return effectiveSuckRangeFactor;
            }

            function checkMountainCollisions() {
                const currentTime = Date.now(); // Get current time for cooldown check

                for (const mountain of mountains) { // mountain is a THREE.Mesh
                    // Create sphere representation for mountain (simplified collision)
                    const mountainCenterThree = mountain.position.clone();
                    mountainCenterThree.y = katamariBody.position.y; // Align Y for horizontal distance calculation

                    // Convert Three.js vector to Cannon.js vector for physics calculations
                    const mountainCenterCannon = new CANNON.Vec3(mountainCenterThree.x, mountainCenterThree.y, mountainCenterThree.z);

                    // Calculate distance using Cannon.js vector method
                    const distance = katamariBody.position.distanceTo(mountainCenterCannon);
                    const mountainRadius = mountain.userData.size; // This is the base radius 'r'

                    // Combined radius for collision check
                    const combinedRadius = katamariRadius + mountainRadius;

                    // If Katamari is too small to pass AND collision is detected
                    if (katamariRadius < mountain.userData.minSizeToPass && distance < combinedRadius) {
                        // Calculate overlap
                        const overlap = combinedRadius - distance;

                        if (overlap > 0) {
                            console.log("Collision with mountain! Katamari too small to pass.");
                            
                            // Mass-dependent impulse calculation
                            // Larger Katamari (higher mass) means less impact from fixed impulse strength
                            // Smaller Katamari means more impact
                            const katamariMass = katamariBody.mass;
                            const mountainImpactFactor = mountainRadius / katamariRadius; // Larger mountain relative to Katamari = more impact
                            const baseImpulseStrength = 10 * 0.2; // Further reduced base strength for less severe push back
                            const cappedMountainImpactFactor = Math.min(2.0, mountainImpactFactor); // Cap impact factor to prevent extreme impulses
                            const impulseStrength = baseImpulseStrength * Math.max(0.2, cappedMountainImpactFactor); // Scale by mountain size relative to Katamari, with a min

                            const collisionNormal = new CANNON.Vec3();
                            katamariBody.position.vsub(mountainCenterCannon, collisionNormal); 
                            collisionNormal.normalize();
                            const impulse = new CANNON.Vec3();
                            collisionNormal.scale(impulseStrength, impulse); 
                            
                            // Add a vertical component to the impulse for bouncing
                            const bounceFactor = 0.05; // Further reduced bounce factor
                            impulse.y += impulseStrength * bounceFactor; // Add upward impulse

                            katamariBody.velocity.x += impulse.x;
                            katamariBody.velocity.y += impulse.y; // Apply vertical impulse
                            katamariBody.velocity.z += impulse.z;

                            // Calculate number of items to shed based on relative sizes
                            const shedAmountFactor = Math.min(1, mountainImpactFactor * 0.5); // Max 100% of items from shedding
                            const maxShedItems = Math.floor(itemsCollectedCount * shedAmountFactor);
                            const itemsToShed = Math.max(1, Math.min(3, maxShedItems)); // Shed at least 1, max 3, or up to maxShedItems

                            // Check cooldown before shedding items
                            if (currentTime - lastShedTime > shedCooldown) {
                                shedSound.triggerAttackRelease("C2", "8n"); // Play sound on bump
                                shakeScreen(0.5); // Add screen shake
                                let shedCount = itemsToShed;
                                if (activePowerUps['stickyCoating']) {
                                    shedCount = Math.floor(shedCount * 0.5); // 50% reduction
                                }
                                shedItems(shedCount); 
                                lastShedTime = currentTime; // Update last shed time
                            }
                        }
                    }
                }
            }

            // New function to create and manage particles
            function createParticles(position, color, type, size = 1, targetPosition = null) {
                const numParticles = type === 'shed' ? 15 : 10 * Math.log(size + 1);
                const particleSize = 0.1 * Math.log(size + 1);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });

                for (let i = 0; i < numParticles; i++) {
                    const particleGeometry = new THREE.SphereGeometry(particleSize, 8, 8);
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone()); // Clone material for individual opacity
                    particle.position.copy(position);

                    // Set random velocity
                    const speed = type === 'shed' ? Math.random() * 5 + 3 : (Math.random() * 2 + 1) * size;
                    const angle = Math.random() * Math.PI * 2;
                    const velocityX = Math.cos(angle) * speed;
                    const velocityZ = Math.sin(angle) * speed;
                    const velocityY = (Math.random() * 3 + 1) * size; // Always some upward velocity

                    particle.userData.velocity = new THREE.Vector3(velocityX, velocityY, velocityZ);
                    particle.userData.lifespan = Math.random() * 0.8 + 0.4; // Lifespan in seconds
                    particle.userData.age = 0;
                    particle.userData.gravity = new THREE.Vector3(0, -9.82, 0); // Apply gravity to particles
                    particle.userData.targetPosition = targetPosition; // Store target position for attraction

                    scene.add(particle);
                    particles.push(particle);
                }
            }

            // Function to update Katamari's physics properties (mass and shape)
            function updateKatamariPhysics() {
                // Update shape
                // Dispose of old shape if it's not the initial one, though Cannon.js handles this internally when replacing
                const newShape = new CANNON.Sphere(katamariRadius);
                katamariBody.shapes = [newShape]; // Replace the old shape with the new one
                katamariBody.shapeOffsets = [new CANNON.Vec3(0, 0, 0)]; // Reset offset if needed
                katamariBody.shapeOrientations = [new CANNON.Quaternion(0, 0, 0, 1)]; // Reset orientation if needed
                
                // Update mass properties: mass = k * radius^3. Here k = 100 / (2^3) = 12.5
                // So, mass = 12.5 * radius^3
                katamariBody.mass = 12.5 * Math.pow(katamariRadius, 3);

                // Ensure minimum height
                katamariBody.position.y = Math.max(katamariRadius, katamariBody.position.y);
                katamari.position.y = katamariBody.position.y;
                katamariBody.updateMassProperties(); // Recalculate inertia and other properties

                // Crucial: Update the physics body's Y position to match the new radius
                // This prevents the Katamari from sinking into the ground as it grows
                katamariBody.position.y = katamariRadius;

                console.log(`Katamari physics updated: Radius=${katamariRadius.toFixed(2)}m, Mass=${katamariBody.mass.toFixed(2)}kg, Y-Pos=${katamariBody.position.y.toFixed(2)}m`);
            }

            // New helper function to encapsulate Katamari size updates
            function updateKatamariVisualsAndPhysics() {
                const coreBall = katamari.getObjectByName('core');
                if (coreBall) {
                    // Dispose old geometry before creating a new one
                    if (coreBall.geometry) {
                        coreBall.geometry.dispose();
                    }
                    coreBall.geometry = new THREE.SphereGeometry(katamariRadius, 32, 32);
                }
                // Update Katamari's physics body mass and shape
                updateKatamariPhysics();

                // Also update Katamari body position to ensure it's on the ground if it shrunk significantly
                katamariBody.position.y = katamariRadius;
                katamari.position.y = katamariRadius;
                console.log(`Katamari visual radius updated to: ${katamariRadius.toFixed(2)}m`);
            }

            // Function to grow Katamari by accretion
            function growKatamari(itemSize) {
                // Calculate growth based on non-linear scaling
                const growthAmount = getGrowthContribution(itemSize, katamariRadius);
                katamariRadius += growthAmount;
                updateKatamariPhysics();

                // Update Katamari's visual geometry and physics body
                updateKatamariVisualsAndPhysics();
            }

            // New function for non-linear growth calculation
            function getGrowthContribution(itemSize, katamariRadius) {
                const baseGrowth = 0.01; // Reduced base growth factor
                const growthRatio = itemSize / katamariRadius;
                const growthAmount = baseGrowth * Math.pow(growthRatio, 0.5) * Math.log(katamariRadius + 1);
                return growthAmount;
            }

            // New function to shed items from the Katamari
            function shedItems(numToShed) {
                console.log(`Attempting to shed ${numToShed} items.`);
                const attachedItems = katamari.children.filter(child => child.name !== 'core');
                if (attachedItems.length === 0) {
                    console.log("No items to shed.");
                    return; // No items to shed
                }

                // Shuffle items and pick the top N
                attachedItems.sort(() => 0.5 - Math.random());
                const itemsToActuallyShed = Math.min(numToShed, attachedItems.length);
                console.log(`Actually shedding ${itemsToActuallyShed} items.`);

                let totalShedSize = 0; // Track total size of shed items
                const dummy = new THREE.Object3D(); // For updating instanced meshes

                for (let i = 0; i < itemsToActuallyShed; i++) {
                    const itemThreeMesh = attachedItems[i];
                    totalShedSize += itemThreeMesh.userData.size; // Add to total shed size
                    
                    // Get world position and quaternion before detaching
                    const worldPosition = new THREE.Vector3();
                    itemThreeMesh.getWorldPosition(worldPosition);
                    const worldQuaternion = new THREE.Quaternion();
                    itemThreeMesh.getWorldQuaternion(worldQuaternion);

                    // Detach from Katamari group
                    katamari.remove(itemThreeMesh);
                    console.log(`Shed item '${itemThreeMesh.userData.size.toFixed(2)}m' detached from Katamari.`);

                    // Clear orbital properties
                    itemThreeMesh.userData.isAttachedToKatamari = false;
                    delete itemThreeMesh.userData.initialLocalPosition;
                    delete itemThreeMesh.userData.rotationSpeed;

                    // Reset item scale (important for instanced items if they were compressed)
                    itemThreeMesh.scale.set(1, 1, 1);

                    // Re-add to scene or update instanced mesh
                    if (itemThreeMesh.userData.isInstanced) {
                        // Re-enable the instance by setting its scale back to 1
                        const instancedMesh = instancedMeshes[itemThreeMesh.userData.instancedId];
                        if (instancedMesh && itemThreeMesh.userData.instanceIndex !== -1) {
                            const dummy = new THREE.Object3D();
                            dummy.position.copy(worldPosition);
                            dummy.quaternion.copy(worldQuaternion);
                            dummy.scale.set(itemThreeMesh.userData.size, itemThreeMesh.userData.size, itemThreeMesh.userData.size); // Revert to original size
                            dummy.updateMatrix();
                            instancedMesh.setMatrixAt(itemThreeMesh.userData.instanceIndex, dummy.matrix);
                            instancedMesh.instanceMatrix.needsUpdate = true;
                            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true; // Update color if it was affected by fade-in
                        }
                    } else {
                        scene.add(itemThreeMesh);
                    }

                    // Add back to itemsToCollect list
                    itemsToCollect.push(itemThreeMesh);

                    // Create a new Cannon.js body for the shed item using its original shape
                    const shedItemSize = itemThreeMesh.userData.size;
                    const newCannonShape = itemThreeMesh.userData.cannonShape; // Retrieve the original shape
                    const shedItemBody = new CANNON.Body({ mass: shedItemSize * 5, shape: newCannonShape });
                    shedItemBody.position.copy(worldPosition);
                    shedItemBody.quaternion.copy(worldQuaternion);
                    shedItemBody.userData = { threeMesh: itemThreeMesh };
                    world.addBody(shedItemBody);
                    physicsBodies.push(shedItemBody);
                    console.log("Shed item re-added to physics world.");

                    // Apply a stronger outward impulse to the shed item for the "pop" animation
                    const impulseDirection = new CANNON.Vec3();
                    shedItemBody.position.vsub(katamariBody.position, impulseDirection);
                    impulseDirection.normalize();
                    impulseDirection.scale(20, impulseDirection); // Increased outward push
                    shedItemBody.applyImpulse(impulseDirection, shedItemBody.position);
                    console.log("Applied impulse to shed item.");

                    // Create particles for shedding
                    let itemColor;
                    if (itemThreeMesh.userData.isInstanced) {
                        itemColor = itemThreeMesh.userData.color; // Use stored color for instanced mesh
                    } else if (itemThreeMesh.isGroup) {
                        itemColor = itemThreeMesh.children[0].material.color;
                    } else {
                        itemColor = itemThreeMesh.material.color;
                    }
                    createParticles(worldPosition, itemColor, 'shed');

                    // Update UI and Katamari visual/physics size
                    itemsCollectedCount--;
                    itemsCollectedUI.textContent = itemsCollectedCount;
                }

                // Reduce Katamari size proportionally to shed items
                const newRadius = Math.max(2, Math.cbrt(Math.pow(katamariRadius, 3) - (totalShedSize * 0.5))); // Reduce by half the total size, minimum radius 2
                targetRadius = newRadius;

                console.log("Finished shedding items.");
            }

            // --- AUDIO FUNCTIONS ---
            function playRollingSound(speed) {
                if (Tone.context.state !== 'running') {
                    Tone.start(); // Use Tone.start()
                }
                if (rollingSynth.state === 'stopped' || rollingSynth.state === 'idle') {
                    rollingSynth.triggerAttack(Tone.context.now());
                }
                const maxSpeed = 20;
                const normalizedSpeed = Math.min(1, speed / maxSpeed);
                const minVolumeDb = -40;
                const maxVolumeDb = -10;
                rollingSynth.volume.value = THREE.MathUtils.lerp(minVolumeDb, maxVolumeDb, normalizedSpeed);
                rollingSynth.noise.playbackRate = 0.5 + normalizedSpeed * 1.5;
            }

            function stopRollingSound() {
                if (rollingSynth.state === 'started') {
                    rollingSynth.triggerRelease(Tone.context.now());
                }
            }

            function playCollectionSound(size = 1) {
                if (Tone.context.state !== 'running') {
                    Tone.start(); // Use Tone.start()
                }
                const now = Tone.context.now();
                if (now - lastCollectionSoundTime > collectionSoundCooldown) {
                    const note = 440 * Math.pow(2, (Math.log(size + 1) / Math.log(100)));
                    collectionSynth.triggerAttackRelease(note, "8n", now);
                    lastCollectionSoundTime = now;
                }
            }

            function attachItem(itemThreeMesh, itemCannonBody) {
                
                // Remove from Cannon.js world
                world.removeBody(itemCannonBody);
                physicsBodies = physicsBodies.filter(body => body !== itemCannonBody);

                // Remove from Three.js items to collect list (no longer immediately removed from scene)
                itemsToCollect = itemsToCollect.filter(item => item !== itemThreeMesh);

                // Increment collected items count and update UI
                itemsCollectedCount++;
                itemsCollectedUI.textContent = itemsCollectedCount;

                // Create particle effect
                let itemColor;
                if (itemThreeMesh.userData.isInstanced) {
                    itemColor = itemThreeMesh.userData.color; // Use stored color for instanced mesh
                } else if (itemThreeMesh.isGroup) {
                    itemColor = itemThreeMesh.children[0].material.color;
                } else {
                    itemColor = itemThreeMesh.material.color;
                }
                createParticles(itemCannonBody.position, itemColor, 'collect', itemThreeMesh.userData.size);

                // Play collection sound
                playCollectionSound(itemThreeMesh.userData.size);

                // Update Katamari size and count
                const itemVolume = Math.pow(itemThreeMesh.userData.size, 3);
                const newVolume = Math.pow(katamariRadius, 3) + itemVolume * 0.1; // Add a fraction of the item's volume
                
                // GROW KATAMARI - REPLACE THIS:
                const oldRadius = katamariRadius;
                katamariRadius = Math.cbrt(Math.pow(oldRadius, 3) + Math.pow(itemThreeMesh.userData.size, 3));
                
                // Adjust position to prevent ground penetration
                const positionAdjustment = katamariRadius - oldRadius;
                katamariBody.position.y += positionAdjustment;
                
                updateKatamariPhysics();
                
                // Ensure we don't go below ground
                katamariBody.position.y = Math.max(katamariRadius, katamariBody.position.y);
                
                targetRadius = Math.cbrt(newVolume);

                // --- New logic for item attachment ---
                // Get the item's world position before it becomes a child
                const itemWorldPosition = itemThreeMesh.position.clone();

                // If it's an instanced mesh, hide the original instance
                if (itemThreeMesh.userData.isInstanced) {
                    const instancedMesh = instancedMeshes[itemThreeMesh.userData.instancedId];
                    if (instancedMesh && itemThreeMesh.userData.instanceIndex !== -1) {
                        const dummy = new THREE.Object3D();
                        dummy.position.copy(itemThreeMesh.position);
                        dummy.quaternion.copy(itemThreeMesh.quaternion);
                        dummy.scale.set(0, 0, 0); // Hide the instance
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(itemThreeMesh.userData.instanceIndex, dummy.matrix);
                        instancedMesh.instanceMatrix.needsUpdate = true;
                        if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
                    }
                    // Create a new regular mesh for the attached item
                    const originalGeometry = instancedGeometries[itemThreeMesh.userData.instancedId];
                    const originalMaterial = instancedMaterials[itemThreeMesh.userData.instancedId].clone(); // Clone material for individual opacity/color
                    originalMaterial.transparent = true;
                    originalMaterial.opacity = 1; // Start fully opaque
                    
                    const attachedVisualMesh = new THREE.Mesh(originalGeometry, originalMaterial);
                    attachedVisualMesh.userData = { ...itemThreeMesh.userData }; // Copy user data
                    attachedVisualMesh.userData.isInstanced = false; // It's now a regular mesh
                    attachedVisualMesh.userData.instanceIndex = -1; // No longer an instance
                    attachedVisualMesh.userData.isAttachedToKatamari = true; // Mark as attached
                    attachedVisualMesh.castShadow = true;
                    attachedVisualMesh.receiveShadow = true;

                    // Add the new regular mesh to the Katamari group
                    katamari.add(attachedVisualMesh);
                    itemThreeMesh = attachedVisualMesh; // Update reference to the new mesh
                } else {
                    // Add the item to the Katamari's Three.js group
                    // This makes itemThreeMesh.position relative to katamari's local origin
                    katamari.add(itemThreeMesh);
                }

                // Now, calculate the desired local position on the Katamari's surface
                // The direction from Katamari's center to the item's original world position
                // needs to be transformed into Katamari's local space.
                const directionFromKatamariCenter = new THREE.Vector3().subVectors(itemWorldPosition, katamari.position);

                // Transform this direction into the Katamari's local space
                // This is equivalent to rotating the direction vector by the inverse of Katamari's quaternion
                const localDirection = directionFromKatamariCenter.applyQuaternion(katamari.quaternion.clone().invert());

                // Normalize and scale to place on surface, with a slight compression
                const minOrbitalDistance = katamariRadius + itemThreeMesh.userData.size * 0.5; // Minimum distance from Katamari center
                localDirection.normalize().multiplyScalar(minOrbitalDistance);

                // Set the item's initial local position
                itemThreeMesh.position.copy(localDirection);

                // Store initial local position and rotation speed for animation
                itemThreeMesh.userData.initialLocalPosition = localDirection.clone();
                itemThreeMesh.userData.rotationSpeed = (Math.random() * 0.5 + 0.2); // Random speed for individual rotation

                // Apply a compression scale to the item for visual effect
                const compressionScale = 0.8; // Adjusted for less scaling
                itemThreeMesh.scale.set(compressionScale, compressionScale, compressionScale);

                // Mark item as attached (if not already done for instanced items)
                itemThreeMesh.userData.isAttachedToKatamari = true;
            }

            function updateCamera(currentSpeed) { // Now receives smoothedSpeed
                // Calculate desired camera position relative to Katamari
                const desiredOffset = new THREE.Vector3(0, 10 + katamariRadius * 1.5, 15 + katamariRadius * 2.5);
                const desiredPosition = katamari.position.clone().add(desiredOffset);

                // Smoothly interpolate camera position
                camera.position.lerp(desiredPosition, 0.2);
                
                // Smoothly interpolate cameraLookAtTarget towards Katamari's actual position
                cameraLookAtTarget.lerp(katamari.position, 0.1); // Adjust interpolation factor as needed

                // Apply screen shake
                if (Date.now() - screenShake.startTime < screenShake.duration) {
                    const percentComplete = (Date.now() - screenShake.startTime) / screenShake.duration;
                    const damper = 1 - percentComplete;
                    const x = (Math.random() - 0.5) * screenShake.intensity * damper;
                    const y = (Math.random() - 0.5) * screenShake.intensity * damper;
                    camera.position.x += x;
                    camera.position.y += y;
                }

                // Revert to looking directly at the Katamari's position
                camera.lookAt(cameraLookAtTarget); 

                // Adjust FOV based on smoothed speed for a sense of motion blur/speed
                const maxFov = 90, minFov = 70, speedThreshold = 15;
                const fov = THREE.MathUtils.lerp(minFov, maxFov, Math.min(1, currentSpeed / speedThreshold));
                camera.fov = fov;
                camera.updateProjectionMatrix();
            }

            // Expose the init function
            return {
                init: init
            };
        })(); // End of IIFE

        // Initialize the game when the window loads
        window.onload = function() {
            // Now, init is accessible via gameModule.init
            gameModule.init(); 
        }
    </script>
</body>
</html>
